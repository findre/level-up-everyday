# 高级数据表示
> 进一步学习 malloc()  
> 使用C表示不同的数据类型  
> 新的算法，从概念上增强抽象能力  
> 抽象数据类型 ADT  

学习吧，少年，学无止境  

## 研究数据表示  

编写一个程序，让用户输入一年内看过的所有电影(DVD 蓝光等)  

要存储每部影片的各种信息，片名，发行年份，导演 ... 

```c
/* film1.c -- 使用一个数据结构 */
#include <stdio.h>
#include <string.h>

#define T_SIZE 45 // 片名长度
#define F_MAX 5   // 影片最大数量

struct film {
    char title[T_SIZE];
    int ratting;
};

char * s_get(char * ptr, int n);

int main(void) {

    struct film movies[F_MAX];
    int i = 0;
    int j;

    puts("> Enter movie");
    while (i < F_MAX && s_get(movies[i].title, T_SIZE) != NULL && movies[i].title[0] != '\0') {
        puts("> Enter ratting");
        scanf("%d", &movies[i].ratting);
        while (getchar() != '\n')
            continue;
        i++;
        puts("> Enter movie");
    }
    if (i==0) {
        puts("> No data");
    } else {
        printf("> Here is movie list ==== > \n");
    }
    for (j=0; j<i; j++) {
        printf("%d) Movie %s Ratting is %d\n", j+1, movies[j].title, movies[j].ratting);
    }
    return 0;
}

char * s_get(char * str_ptr, int n) {
    char * ret_val;
    char * find;
    ret_val = fgets(str_ptr, n, stdin);
    if (ret_val) {
        find = strchr(str_ptr, '\n');
        if (find != NULL) {
            *find = '\0';
        } else {
            while (getchar() != '\n')
                continue;
        }
    }
    return ret_val;
}
```
代码输出

```                 
> Enter movie
泰坦尼克号
> Enter ratting
9
> Enter movie
古罗马斗兽场
> Enter ratting
9
> Enter movie
大国工匠
> Enter ratting
9
> Enter movie
那年我
> Enter ratting
9
> Enter movie
双手插兜
> Enter ratting
8
> Enter movie
> Here is movie list ==== > 
1) Movie 泰坦尼克号 Ratting is 9
2) Movie 古罗马斗兽场 Ratting is 9
3) Movie 大国工匠 Ratting is 9
4) Movie 那年我 Ratting is 9
5) Movie 双手插兜 Ratting is 8
```
程序本身没什么难点  

该程序创建了一个数组，数组里存储 `film` 结构体，用 `F_MAX` 宏判断数组是否满  

但是有点问题，就是空间浪费  

因为大部分电影名称都不会超过 `40` 个字符  

并且，多大的`F_MAX` 才是合适的，对有些人来说，5个太少，但是最大量该是多大 不好评估  

这样就浪费了大量内存  

另外 一些编译器对自动存储变量（如`movies`）设定了最大存储限制  

该程序的问题是 过于死板，不够灵活 

真正要解决这个问题，应该让内存的分配更加灵活  

```c
#define T_SIZE 45
strcut film {
    char title[T_SIZE];
    int ratting;
}
// ...
int n, i;
struct film * movies; // 指向结构的指针
// ...

printf("puts movies count");
movies = (struct film *) malloc (n * sizeof(struct film)); // 动态分配
```

使用 malloc 可以推迟到运行时来确定程序使用多少空间来装电影  

但是需要用户能明确的知道电影的数量  

<br>  

## 从数组到链表  

最理想的状态是，用户每输入一次电影，就 `malloc()` 一次进行内存分配  
这样就不需要用户提前输入电影数量，程序可以相对更加灵活  

不过，我们又制造了另一个麻烦  

1) 调用一次 `malloc` 一次申请 300个 `movie`
2) 调用 300次 `malloc` 每次申请一个 `movie`

前者申请的是一个连续的内存块儿，只需要一个指针就能索引这 300 个电影 
后者没办法保证每次 `malloc()` 都能在一个连续的内存块儿上分配 `film`  
与第一种相比，可能需要存储 300个指针去指向 数据  

一种方法是，先构造一个超大的数组，然后每次分配内存都在这个数组中进行 

```c
#define FMAX 5000;
struct film {
    char title[T_MAX];
    ratting
}
// ....
struct * film movies[F_MAX];
movies[i] = (struct film *) malloc (sizeof(struct film))
```

500个指针的数组 比 500个结构体的数组小了很多, 但是还是浪费了不少看空间  

也不理想 

还有一种更好的方法，每次用 `malloc()` 为新 `struct film` 分配空间时候  
也为新指针分配空间，但是还需要另一个指针去跟踪新分配的指针 
用于跟踪的新指针本身，也需要一个指针来跟踪  
以此类推，需要改变结构本身来完成  
即每个结构中，包含指向`next`的指针  
在新分配 `struct film` 时候，将结构体指针赋值给上一个结构体的 `next` 对象

```c
struct film {
    char title[T_SIZE];
    int ratting;
    struct film * next;
}
```

__虽然结构不能包含与本身类型相同的结构，但是可以包含本身结构的指针__  
这种定义是定义 **链表(linked list)** 的基础  
链表中的每一项，都包含着在何处能找到下一项的信息  

哈哈哈哈哈～

### 使用链表

废话少说！上代码！

```c
/* films2.c -- 使用链表结构 */
#include <stdio.h>
#include <stdlib.h> /* 提供了 malloc() 原型 */
#include <string.h> /* 提供了 strcpy() 原型 */
#define T_SIZE 45   /* 片名长度 */

struct film {
    char title[T_SIZE];
    int ratting;
    struct film * next; // 指向链表的下一个结构
};

char * s_get(char * ptr, int n);

int main(void) {

    struct film * head = NULL;      // 声明头指针
    struct film * prev;
    struct film * next;
    struct film * current;
    char input[T_SIZE];  // 存放用户输入

    /* 收集并且存储信息 */
    puts("Enter movie title");
    while (s_get(input, T_SIZE) != NULL && input[0] != '\0') {
        current = (struct film *) malloc(sizeof(struct film)); // 分配
        if (head == NULL) {
            head = current;
        } else {
            prev->next = current;
        }
        current->next = NULL;
        strcpy(current->title, input);
        printf("> Input %s ratting: ", current->title);
        scanf("%d", &current->ratting);
        while (getchar() != '\n')
            continue;
        puts("Enter next movie title (empty to stop);");
        prev = current;
    }

    /* 显示电影列表 */
    if (head == NULL)
        puts("No data");
    else
        puts("The movie list is ==== >");
    current = head;
    while (current != NULL) {
        printf("> Movie << %s >>, ratting is %d. \n", current->title, current->ratting);
        current = current->next;
    }

    /* 显示完毕，开始释放内存 此刻 current == NULL */
    current = head; // 重新指向头指针
    if (current != NULL) {
        /* 如果 head 此时不为NULL */
        while (current != NULL) {
            next = current->next; // 提取下一个地址，可能为 NULL.
            free(current);        // 释放当前地址申请的内存空间, 但是结构还在，还能拿到下一个地址，只不过当前地址被标记为已释放，随时可能被修改
            current = next;       // 将当前地址的指针，指向下一个地址
        }
    }
    puts("Free success, Bye");
    return 0;
}

char * s_get(char * str_ptr, int n) {
    char * ret_val;
    char * find;
    ret_val = fgets(str_ptr, n, stdin);
    if (ret_val) {
        find = strchr(str_ptr, '\n');
        if (find != NULL) {
            *find = '\0';
        } else {
            while (getchar() != '\n')
                continue;
        }
    }
    return ret_val;
}
```
代码输出
```
Enter movie title
那年
> Input 那年 ratting: 9
Enter next movie title (empty to stop);
我双手
> Input 我双手 ratting: 9
Enter next movie title (empty to stop);
插兜
> Input 插兜 ratting: 9
Enter next movie title (empty to stop);
不知道
> Input 不知道 ratting: 0
Enter next movie title (empty to stop);
什么
> Input 什么 ratting: 9
Enter next movie title (empty to stop);
叫做
> Input 叫做 ratting: 9
Enter next movie title (empty to stop);
对手
> Input 对手 ratting: 9
Enter next movie title (empty to stop);

The movie list is ==== >
> Movie << 那年 >>, ratting is 9. 
> Movie << 我双手 >>, ratting is 9. 
> Movie << 插兜 >>, ratting is 9. 
> Movie << 不知道 >>, ratting is 0. 
> Movie << 什么 >>, ratting is 9. 
> Movie << 叫做 >>, ratting is 9. 
> Movie << 对手 >>, ratting is 9. 
Bye
```

手真爽，脑真爽  

感觉没啥可说的 代码写的很清楚  

此处代码针对 `free` 部分做了些修改  

原版代码:

```c
current = head;
while(current != NULL)
    current = head;
    head = current.next;
    free(current);
```
感觉有点奇怪，说不上来 

修改后我加入了临时 `next` 变量来指向下一个节点的地址  

### 反思  

哈哈哈哈，太典了，反思，来吧，反思吧  

1. 程序没有检查是否成功申请到内存
2. 也无法删除链表中的项（一环扣一环）
3. 先别反思了 继续写吧  

<br>  

## 抽象数据类型 (ADT)

抽象的本质就是用计算机编程语言的类型或过程，去描述实际生活或者业务场景中的实体，或过程  

比如前面的 电影链表结构、或者用 `int` 表示鞋子个数，用 `double` 描述克数

但是上述做法并不系统，如何用更系统的方式来抽象这个世界？？ 

关于`ADT`

1. 提供类型属性和相关操作的描述，这些描述不能依赖特定实现，也不能依赖特定的编程语言 
2. 开发和实现一个ADT的编程接口，也就是说指明操作数据和过程的函数
3. 编写代码实现的接口

### 建立抽象  

从根本上看 电影项目所需要的是一个链表  
每一项包含电影和评级  
你所需要做的，就是把新项添加到链表的末尾，显示节点对应的内容  
链表具有哪些属性？

- 初始化空链表
- 在链表末尾添加新项
- 确定链表是否为空
- 确定链表是否已满
- 确定链表中的项目数量
- 访问链表中的某一项，对齐进行操作
- 在链表中的任意位置插入一项
- 移除链表中的某一项
- 在链表中检索一项（不改变链表）
- 用另一个项目代替某一项
- 在链表中搜索一个项

非正式但是抽象的链表定义是：**链表是一个可以储存一系列项目，并对齐操作的数据对象**  

下一步为了简单链表开发一个C接口  

### 建立接口

简单链表的接口有2部分，第一部分用来描述数据，第二部分是实现`ADT`操作的函数

抽象应该海纳百川，而不应该局限于某一种或者几种类型  

```c
#define T_SIZE 45
struct film {
    char title[T_SIZE]
    int ratting;
};
typedef struct film Item;
```

然后就可以在定义的其余部分，使用 Item 类型  

如果以后需要除了电影以外的类型来使用链表，直接更改 `typedef` 即可  

定义好 `Item` 后，现在必须确定如何存储这些实际的项目  

其实这一步是`ADT`的具体实现，但是别穷讲究，该咋来咋来  

```c
typedef struct node 
{
    Item item;
    struct node * next;
} Node;

typedef Node * List;
```

这一步，我们将 `Item` 集成到 `Node` 类型中去，作为一个类型嵌套  

然后抽离了原本 `Item` 中的 `next` 指针，作为 Node 对象的私有属性。

这样 `Item` 和 `Node` 本身就玻璃开了，开发人员只需要关注 `Item` 有什么就好   

不用关心 已经实现过的 `Node` 层级。

声明 `Node` 类型的指针对象 `List`, 链表的每一个节点通常被称为 `node`  

指针可以移动，`List` 这个名称符合链表上蹿下跳的特性

`List` 还有一种表示方式  

```c
typedef struct list {
    Node * head; // 指向头节点
    int size;    // 记录链表大小
} List           // List 的另一种定义
```

不过教程中还是使用第一种定义，也就是 
```c
typedef Node * List;
```

我们在声明电影时候，可以这样：
```c
List movies;
```

是不是很直观？

`movies` 代表的具体数据，应该是接口层不可见的实现细节  

使用链表的开发人员应该无需关注具体实现，只要无脑调用：

```c
InitializeList(movies) // 初始化一个链表
```
__数据隐藏是一种从编程的更高层次隐藏数据表示细节的艺术__

差不多了 上头文件

```c
/* list.h 头文件 */
#ifndef FIST_LIST_H
#define FIST_LIST_H
#include <stdbool.h> /* C99 true false */

#define TITLE_SIZE 45 /* 电影名大小 */

/* 电影的数据结构 */
struct film {
    char * title[TITLE_SIZE];
    int ratting;
};

/* 将电影抽象为 ITEM */
typedef struct film Item;

/* 抽象 Node 节点结构，包含 Item 和 next */
typedef struct node {
    Item item;
    struct node * next;
} Node;

/* 抽象 List 代表链表 */
typedef Node * List;

/* 函数原型 */
/* 操作：    初始化链表 */
/* 前置条件： plist 指向一个空链表 */
/* 后置条件： 链表初始化为空 */
void InitializeList(List * plist);

/* 操作: 确定链表是否为空定义，plist 指向一个已初始化的链表 */
/* 后置条件：如果链表为空，返回 true 否则返回 false */
bool ListIsEmpty(List * plist);

/* 操作：确定链表是否已经满，plist 指向一个已经初始化的链表 */
/* 后置条件：如果链表已满，返回 true 否则返回 false */
bool ListIsFull(List * plist);

/* 操作：确定链表中的节点数量，plist 指向一个已经初始化的链表 */
/* 后置条件：返回链表中项目数 */
unsigned int ListItemCount(List * plist);

/* 操作：向链表中添加项目，plist 指向一个已经初始化的链表 */
/* 前置条件：item 是一个已经完成初始化的 Item 对象 */
/* 后置条件：添加成功返回 true 否则返回 false */
bool AddItem(Item item, List * plist);

/* 操作：   把 pfun 函数作用域链表的每一项 */
/*         plist 指向一个已经初始化的链表 */
/*         pfun 没有返回值，接受一个 Item 对象 */
void Traverse(const List * plist, void (*pfun)(Item item));

/* 操作：释放链表内存 */
void EmptyList(List * plist);

#endif //FIST_LIST_H
```



