# 高级数据表示
> 进一步学习 malloc()  
> 使用C表示不同的数据类型  
> 新的算法，从概念上增强抽象能力  
> 抽象数据类型 ADT  

学习吧，少年，学无止境  

## 研究数据表示  

编写一个程序，让用户输入一年内看过的所有电影(DVD 蓝光等)  

要存储每部影片的各种信息，片名，发行年份，导演 ... 

```c
/* film1.c -- 使用一个数据结构 */
#include <stdio.h>
#include <string.h>

#define T_SIZE 45 // 片名长度
#define F_MAX 5   // 影片最大数量

struct film {
    char title[T_SIZE];
    int ratting;
};

char * s_get(char * ptr, int n);

int main(void) {

    struct film movies[F_MAX];
    int i = 0;
    int j;

    puts("> Enter movie");
    while (i < F_MAX && s_get(movies[i].title, T_SIZE) != NULL && movies[i].title[0] != '\0') {
        puts("> Enter ratting");
        scanf("%d", &movies[i].ratting);
        while (getchar() != '\n')
            continue;
        i++;
        puts("> Enter movie");
    }
    if (i==0) {
        puts("> No data");
    } else {
        printf("> Here is movie list ==== > \n");
    }
    for (j=0; j<i; j++) {
        printf("%d) Movie %s Ratting is %d\n", j+1, movies[j].title, movies[j].ratting);
    }
    return 0;
}

char * s_get(char * str_ptr, int n) {
    char * ret_val;
    char * find;
    ret_val = fgets(str_ptr, n, stdin);
    if (ret_val) {
        find = strchr(str_ptr, '\n');
        if (find != NULL) {
            *find = '\0';
        } else {
            while (getchar() != '\n')
                continue;
        }
    }
    return ret_val;
}
```
代码输出

```                 
> Enter movie
泰坦尼克号
> Enter ratting
9
> Enter movie
古罗马斗兽场
> Enter ratting
9
> Enter movie
大国工匠
> Enter ratting
9
> Enter movie
那年我
> Enter ratting
9
> Enter movie
双手插兜
> Enter ratting
8
> Enter movie
> Here is movie list ==== > 
1) Movie 泰坦尼克号 Ratting is 9
2) Movie 古罗马斗兽场 Ratting is 9
3) Movie 大国工匠 Ratting is 9
4) Movie 那年我 Ratting is 9
5) Movie 双手插兜 Ratting is 8
```
程序本身没什么难点  

该程序创建了一个数组，数组里存储 `film` 结构体，用 `F_MAX` 宏判断数组是否满  

但是有点问题，就是空间浪费  

因为大部分电影名称都不会超过 `40` 个字符  

并且，多大的`F_MAX` 才是合适的，对有些人来说，5个太少，但是最大量该是多大 不好评估  

这样就浪费了大量内存  

另外 一些编译器对自动存储变量（如`movies`）设定了最大存储限制  

该程序的问题是 过于死板，不够灵活 

真正要解决这个问题，应该让内存的分配更加灵活  

```c
#define T_SIZE 45
strcut film {
    char title[T_SIZE];
    int ratting;
}
// ...
int n, i;
struct film * movies; // 指向结构的指针
// ...

printf("puts movies count");
movies = (struct film *) malloc (n * sizeof(struct film)); // 动态分配
```

使用 malloc 可以推迟到运行时来确定程序使用多少空间来装电影  

但是需要用户能明确的知道电影的数量  

<br>  

## 从数组到链表  

最理想的状态是，用户每输入一次电影，就 `malloc()` 一次进行内存分配  
这样就不需要用户提前输入电影数量，程序可以相对更加灵活  

不过，我们又制造了另一个麻烦  

1) 调用一次 `malloc` 一次申请 300个 `movie`
2) 调用 300次 `malloc` 每次申请一个 `movie`

前者申请的是一个连续的内存块儿，只需要一个指针就能索引这 300 个电影 
后者没办法保证每次 `malloc()` 都能在一个连续的内存块儿上分配 `film`  
与第一种相比，可能需要存储 300个指针去指向 数据  

一种方法是，先构造一个超大的数组，然后每次分配内存都在这个数组中进行 

```c
#define FMAX 5000;
struct film {
    char title[T_MAX];
    ratting
}
// ....
struct * film movies[F_MAX];
movies[i] = (struct film *) malloc (sizeof(struct film))
```

500个指针的数组 比 500个结构体的数组小了很多, 但是还是浪费了不少看空间  

也不理想 

还有一种更好的方法，每次用 `malloc()` 为新 `struct film` 分配空间时候  
也为新指针分配空间，但是还需要另一个指针去跟踪新分配的指针 
用于跟踪的新指针本身，也需要一个指针来跟踪  
以此类推，需要改变结构本身来完成  
即每个结构中，包含指向`next`的指针  
在新分配 `struct film` 时候，将结构体指针赋值给上一个结构体的 `next` 对象

```c
struct film {
    char title[T_SIZE];
    int ratting;
    struct film * next;
}
```

__虽然结构不能包含与本身类型相同的结构，但是可以包含本身结构的指针__  
这种定义是定义 **链表(linked list)** 的基础  
链表中的每一项，都包含着在何处能找到下一项的信息  

哈哈哈哈哈～

### 使用链表

废话少说！上代码！

```c
/* films2.c -- 使用链表结构 */
#include <stdio.h>
#include <stdlib.h> /* 提供了 malloc() 原型 */
#include <string.h> /* 提供了 strcpy() 原型 */
#define T_SIZE 45   /* 片名长度 */

struct film {
    char title[T_SIZE];
    int ratting;
    struct film * next; // 指向链表的下一个结构
};

char * s_get(char * ptr, int n);

int main(void) {

    struct film * head = NULL;      // 声明头指针
    struct film * prev;
    struct film * next;
    struct film * current;
    char input[T_SIZE];  // 存放用户输入

    /* 收集并且存储信息 */
    puts("Enter movie title");
    while (s_get(input, T_SIZE) != NULL && input[0] != '\0') {
        current = (struct film *) malloc(sizeof(struct film)); // 分配
        if (head == NULL) {
            head = current;
        } else {
            prev->next = current;
        }
        current->next = NULL;
        strcpy(current->title, input);
        printf("> Input %s ratting: ", current->title);
        scanf("%d", &current->ratting);
        while (getchar() != '\n')
            continue;
        puts("Enter next movie title (empty to stop);");
        prev = current;
    }

    /* 显示电影列表 */
    if (head == NULL)
        puts("No data");
    else
        puts("The movie list is ==== >");
    current = head;
    while (current != NULL) {
        printf("> Movie << %s >>, ratting is %d. \n", current->title, current->ratting);
        current = current->next;
    }

    /* 显示完毕，开始释放内存 此刻 current == NULL */
    current = head; // 重新指向头指针
    if (current != NULL) {
        /* 如果 head 此时不为NULL */
        while (current != NULL) {
            next = current->next; // 提取下一个地址，可能为 NULL.
            free(current);        // 释放当前地址申请的内存空间, 但是结构还在，还能拿到下一个地址，只不过当前地址被标记为已释放，随时可能被修改
            current = next;       // 将当前地址的指针，指向下一个地址
        }
    }
    puts("Free success, Bye");
    return 0;
}

char * s_get(char * str_ptr, int n) {
    char * ret_val;
    char * find;
    ret_val = fgets(str_ptr, n, stdin);
    if (ret_val) {
        find = strchr(str_ptr, '\n');
        if (find != NULL) {
            *find = '\0';
        } else {
            while (getchar() != '\n')
                continue;
        }
    }
    return ret_val;
}
```
代码输出
```
Enter movie title
那年
> Input 那年 ratting: 9
Enter next movie title (empty to stop);
我双手
> Input 我双手 ratting: 9
Enter next movie title (empty to stop);
插兜
> Input 插兜 ratting: 9
Enter next movie title (empty to stop);
不知道
> Input 不知道 ratting: 0
Enter next movie title (empty to stop);
什么
> Input 什么 ratting: 9
Enter next movie title (empty to stop);
叫做
> Input 叫做 ratting: 9
Enter next movie title (empty to stop);
对手
> Input 对手 ratting: 9
Enter next movie title (empty to stop);

The movie list is ==== >
> Movie << 那年 >>, ratting is 9. 
> Movie << 我双手 >>, ratting is 9. 
> Movie << 插兜 >>, ratting is 9. 
> Movie << 不知道 >>, ratting is 0. 
> Movie << 什么 >>, ratting is 9. 
> Movie << 叫做 >>, ratting is 9. 
> Movie << 对手 >>, ratting is 9. 
Bye
```

手真爽，脑真爽  

感觉没啥可说的 代码写的很清楚  

此处代码针对 `free` 部分做了些修改  

原版代码:

```c
current = head;
while(current != NULL)
    current = head;
    head = current.next;
    free(current);
```
感觉有点奇怪，说不上来 

修改后我加入了临时 `next` 变量来指向下一个节点的地址  

### 反思  

哈哈哈哈，太典了，反思，来吧，反思吧  

1. 程序没有检查是否成功申请到内存
2. 也无法删除链表中的项（一环扣一环）
3. 先别反思了 继续写吧  

<br>  

## 抽象数据类型 (ADT)

抽象的本质就是用计算机编程语言的类型或过程，去描述实际生活或者业务场景中的实体，或过程  

比如前面的 电影链表结构、或者用 `int` 表示鞋子个数，用 `double` 描述克数

但是上述做法并不系统，如何用更系统的方式来抽象这个世界？？ 

关于`ADT`

1. 提供类型属性和相关操作的描述，这些描述不能依赖特定实现，也不能依赖特定的编程语言 
2. 开发和实现一个ADT的编程接口，也就是说指明操作数据和过程的函数
3. 编写代码实现的接口

### 建立抽象  

从根本上看 电影项目所需要的是一个链表  
每一项包含电影和评级  
你所需要做的，就是把新项添加到链表的末尾，显示节点对应的内容  
链表具有哪些属性？

- 初始化空链表
- 在链表末尾添加新项
- 确定链表是否为空
- 确定链表是否已满
- 确定链表中的项目数量
- 访问链表中的某一项，对齐进行操作
- 在链表中的任意位置插入一项
- 移除链表中的某一项
- 在链表中检索一项（不改变链表）
- 用另一个项目代替某一项
- 在链表中搜索一个项

非正式但是抽象的链表定义是：**链表是一个可以储存一系列项目，并对齐操作的数据对象**  

下一步为了简单链表开发一个C接口  

### 建立接口

简单链表的接口有2部分，第一部分用来描述数据，第二部分是实现`ADT`操作的函数

抽象应该海纳百川，而不应该局限于某一种或者几种类型  

```c
#define T_SIZE 45
struct film {
    char title[T_SIZE]
    int ratting;
};
typedef struct film Item;
```

然后就可以在定义的其余部分，使用 Item 类型  

如果以后需要除了电影以外的类型来使用链表，直接更改 `typedef` 即可  

定义好 `Item` 后，现在必须确定如何存储这些实际的项目  

其实这一步是`ADT`的具体实现，但是别穷讲究，该咋来咋来  

```c
typedef struct node 
{
    Item item;
    struct node * next;
} Node;

typedef Node * List;
```

这一步，我们将 `Item` 集成到 `Node` 类型中去，作为一个类型嵌套  

然后抽离了原本 `Item` 中的 `next` 指针，作为 Node 对象的私有属性。

这样 `Item` 和 `Node` 本身就玻璃开了，开发人员只需要关注 `Item` 有什么就好   

不用关心 已经实现过的 `Node` 层级。

声明 `Node` 类型的指针对象 `List`, 链表的每一个节点通常被称为 `node`  

指针可以移动，`List` 这个名称符合链表上蹿下跳的特性

`List` 还有一种表示方式  

```c
typedef struct list {
    Node * head; // 指向头节点
    int size;    // 记录链表大小
} List           // List 的另一种定义
```

不过教程中还是使用第一种定义，也就是 
```c
typedef Node * List;
```

我们在声明电影时候，可以这样：
```c
List movies;
```

是不是很直观？

`movies` 代表的具体数据，应该是接口层不可见的实现细节  

使用链表的开发人员应该无需关注具体实现，只要无脑调用：

```c
InitializeList(movies) // 初始化一个链表
```
__数据隐藏是一种从编程的更高层次隐藏数据表示细节的艺术__

差不多了 上头文件

```c
/* list.h 头文件 */
#ifndef FIST_LIST_H
#define FIST_LIST_H
#include <stdbool.h> /* C99 true false */

#define TITLE_SIZE 45 /* 电影名大小 */

/* 电影的数据结构 */
struct film {
    char * title[TITLE_SIZE];
    int ratting;
};

/* 将电影抽象为 ITEM */
typedef struct film Item;

/* 抽象 Node 节点结构，包含 Item 和 next */
typedef struct node {
    Item item;
    struct node * next;
} Node;

/* 抽象 List 代表链表 */
typedef Node * List;

/* 函数原型 */
/* 操作：    初始化链表 */
/* 前置条件： plist 指向一个空链表 */
/* 后置条件： 链表初始化为空 */
void InitializeList(List * plist);

/* 操作: 确定链表是否为空定义，plist 指向一个已初始化的链表 */
/* 后置条件：如果链表为空，返回 true 否则返回 false */
bool ListIsEmpty(List * plist);

/* 操作：确定链表是否已经满，plist 指向一个已经初始化的链表 */
/* 后置条件：如果链表已满，返回 true 否则返回 false */
bool ListIsFull(List * plist);

/* 操作：确定链表中的节点数量，plist 指向一个已经初始化的链表 */
/* 后置条件：返回链表中项目数 */
unsigned int ListItemCount(List * plist);

/* 操作：向链表中添加项目，plist 指向一个已经初始化的链表 */
/* 前置条件：item 是一个已经完成初始化的 Item 对象 */
/* 后置条件：添加成功返回 true 否则返回 false */
bool AddItem(Item item, List * plist);

/* 操作：   把 pfun 函数作用域链表的每一项，不可修改列表 */
/*         plist 指向一个已经初始化的链表 */
/*         pfun 没有返回值，接受一个 Item 对象 */
void Traverse(const List * plist, void (*pfun)(Item item));

/* 操作：释放链表内存 */
void EmptyList(List * plist);

#endif //FIST_LIST_H
```

如何使用这个链表？上代码 

```c
/* films3.c -- 使用抽象数据类型风格编写链表 */
#include <stdio.h>
#include <stdlib.h> /* 提供了 exit() 原型 */
#include <string.h>
#include "list.h"

void show_movies(Item item);
char * s_get(char *, int);

int main(void) {
    List movies;
    Item temp;

    /* 初始化链表 */
    InitializeList(&movies);
    if (ListIsFull(&movies)) {
        fprintf(stderr, "Mo memory available! Bye!\n");
        exit(EXIT_FAILURE);
    }

    /* 获取用户输入并且储存 */
    puts("Input the movie title, (empty to quit)");
    while (s_get(temp.title, TITLE_SIZE) != NULL && temp.title[0] != '\0') {
        puts("Input the movie ratting");
        scanf("%d", &temp.ratting);
        while (getchar() != '\n')
            continue;
        if (AddItem(temp, &movies) == false) {
            fprintf(stderr, "Problem alloc memory\n");
            break;
        }
        if (ListIsFull(&movies)) {
            puts("The list is now full");
            break;
        }
        puts("Input the movie title, (empty to quit)");
    }

    /* 显示链表中的内容 */
    if (ListIsEmpty(&movies) == false) {
        puts("Here is movies list: ");
        Traverse(&movies, show_movies);
    } else {
        puts("The movies is empty");
    }

    /* 清理链表 */
    EmptyList(&movies);
    puts("Bye");

    return 0;
}

void show_movies(Item item) {
    printf("> Movie %s Ratting: %d\n", *item.title, item.ratting);
}

char * s_get(char * str_ptr, int n) {
    char * ret_val;
    char * find;
    ret_val = fgets(str_ptr, n, stdin);
    if (ret_val) {
        find = strchr(str_ptr, '\n');
        if (find != NULL) {
            *find = '\0';
        } else {
            while (getchar() != '\n')
                continue;
        }
    }
    return ret_val;
}
```

### 实现接口  

```c
/* list.c */
#include <stdio.h>
#include <stdlib.h>
#include "list.h"

/* 局部函数原型 */
static void CopyToNode(Item item, Node * p_node);

/* 初始化链表 */
void InitializeList(List * plist) {
    *plist = NULL;
}

bool ListIsEmpty(const List * plist) {
    if (*plist == NULL) {
        return true;
    } else {
        return false;
    }
}

bool ListIsFull(const List * plist) {
    Node * pt;
    bool full = false;
    pt = (Node *) malloc (sizeof (Node));
    if (pt == NULL) {
        full = true;
    }
    free(pt);
    return full;
}

unsigned int ListItemCount(const List * plist) {
    unsigned int count = 0;
    Node * p_node = *plist;    /* 声明 p_node 指向链表的开始 */
    while (p_node != NULL) {
        ++count;
        p_node = p_node->next; /* 设置 p_node 指向下一个节点 */
    }
    return count;
}

bool AddItem(Item item, List * plist) {
    Node * p_new;          // 声明 新节点
    Node * scan = *plist; // 声明 指向 plist 开头的指针
    p_new = (Node *) malloc(sizeof(Node));
    if (p_new == NULL) {
        return false;
    }
    CopyToNode(item, p_new);
    p_new->next = NULL;
    if (scan == NULL) /* 判断是否为空 */ {
        *plist = p_new; // 设置头节点
    } else {
        while (scan->next != NULL)
            scan = scan->next; // loop 到 链表末尾
        scan->next = p_new;    // 将末尾的 next 设置为 p_new
    }
    return true;
}

void Traverse(const List * plist, void (*pfun)(Item item)) {
    Node * temp = *plist;
    while (temp != NULL) {
        (*pfun)(temp->item);
        temp = temp->next;
    }
}

void EmptyList(List * plist) {
    Node * current = *plist; // 指向头节点
    Node * next = NULL;      // 构建空指针
    while (current != NULL) {
        next = current->next; // next 指向下一个节点；
        free(current);
        current = next;
    }
}

void CopyToNode(Item item, Node * p_node) {
    p_node->item = item;
}
```

编译 main.c 和 list.c
```shell
gcc -o prog -Wall main.c list.c
```

执行程序，代码输出
```
Input the movie title, (empty to quit)
那年
Input the movie ratting
9
Input the movie title, (empty to quit)
我双手
Input the movie ratting
9
Input the movie title, (empty to quit)
插兜
Input the movie ratting
9
Input the movie title, (empty to quit)
不知道
Input the movie ratting
0
Input the movie title, (empty to quit)
什么
Input the movie ratting
9
Input the movie title, (empty to quit)
叫做
Input the movie ratting
9
Input the movie title, (empty to quit)
对手
Input the movie ratting
9
Input the movie title, (empty to quit)

Here is movies list: 
> Movie 那年 Ratting: 9.
> Movie 我双手 Ratting: 9.
> Movie 插兜 Ratting: 9.
> Movie 不知道 Ratting: 0.
> Movie 什么 Ratting: 9.
> Movie 叫做 Ratting: 9.
> Movie 对手 Ratting: 9.
Bye
```
`static` 存储类别，可以让对象的存储周期局限于文件内部  

初始化列表其实就是将头指针指向 `NULL` 为接下来的分配做准备  

`plist` 是一个指向指针的指针  

<br>  

## 队列 ADT

抽象数据方法ADT主要包括：
1. 以抽象、通用的方式描述一种数据类型，以及对应操作
2. 设计一个函数接口表示这种新数据类型
3. 编写具体的代码实现这种类型  

前面实现了链表，接下来实现队列  

### 定义队列抽象数据类型  

队列可以理解为是一种特殊的链表，它需要满足 
1. 新项目只能添加到链表的末尾 
2. 只能从链表的头部开始移除项目，也就是**先进先出 first in, first out**

### 定义队列接口

```c
typedef struct item {} Item;
typedef struct queue {} Queue;

void InitializeQueue(Queue * pq);     // 初始化队列
bool QueueIsFull(const Queue * pq);   // 判断队列是否已满，注意这里传的是地址
bool QueueIsEmpty(const Queue * pq);  // 判断队列是否为空，注意这里传的是地址
bool QueueItemCount(const Queue *pq); // 获取队列中的 item 数量
bool EnQueue(Queue * pq, Item * item);  // item 写入队列
bool DeQueue(Item * item, Queue * pq);  // 删除队列中的项目，将删除项目内容写入 item
void EmptyQueue(Queue * pq) // 删除队列释放内存
```

### 实现数据表示  

#### 简单数组
首先确定使用什么样的C数据类型，数组的有点明显，可以很方便的插入数据   
在删除上有点门道，**可以把头数据移除后，所有数据向前移动一位，但是这样会浪费性能**    

#### 环形队列
还有一种方法，**环形队列**  
把队列的收尾相连，即数组的首元素始终跟在结尾元素的后面  
变成一个圆圈  
一般情况下都是固定大小的，同时要避免队尾超过队首  

#### 使用链表  
使用链表的好处是删除时候不用移动项目，只需要重置头指针指向新元素即可  
鉴于之前测试过了链表，所以此处仍然使用链表实现  

上代码 

```c
#ifndef FIST_QUEUE_H
#define FIST_QUEUE_H
/* queue.h -- Queue 的原型 */
#include <stdbool.h>

typedef int Item;

#define MAX_QUEUE 10;

typedef struct node {
    Item item;
    struct node * next;
} Node;

typedef struct queue {
    Node * front;
    Node * end;
    int items;
} Queue;

void InitializeQueue(Queue * pq);

bool QueueIsFull(Queue * pq);

bool QueueIsEmpty(Queue * pq);

int QueueItemCount(const Queue * pq);

/* 操作：从队列尾部进行元素添加 */
/* 后置条件：成功添加返回 true 失败返回 false */
bool EnQueue(Item item, Queue * pq);

/* 操作：从队列头部进行元素删除，并将删除的元素写到 p_item 地址上 */
bool DeQueue(Item *p_item, Queue * pq);

void EmptyQueue(Queue * pq);

#endif //FIST_QUEUE_H
```
实现队列接口
```c
/* queue.c -- queue.h 接口 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "queue.h"

static void CopyToNode(Item item, Node * node);
static void CopyToItem(Node * pn, Item * pi);

void InitializeQueue(Queue * pq) {
    pq->front = NULL;
    pq->rear = NULL;
    pq->items = 0;
}

bool QueueIsEmpty(Queue * pq) {
    return pq->items <= 0;
}

bool QueueIsFull(Queue * pq) {
    return pq->items >= MAX_QUEUE;
}

int QueueItemCount(const Queue * pq) {
    return pq->items;
}

bool EnQueue(Item item, Queue * pq) {
    Node * p_new;
    if (QueueIsFull(pq)) {
        fprintf(stderr, "Queue is Full\n");
        return false;
    }
    p_new = (Node *) malloc(sizeof(Node));
    if (p_new == NULL) {
        fprintf(stderr, "Malloc memory failed.\n");
        exit(EXIT_FAILURE);
    }
    CopyToNode(item, p_new);
    if (QueueIsEmpty(pq)) {
        pq->front = p_new;      // 队头指针记录;
    } else {
        /* 链接新 p_new 地址到队列尾端 node 的 next 节点
         * 因为它本质上仍然是个链表，
         * 是链表，就需要维护好链表的上下节点关系;
         */
        pq->rear->next = p_new;
    }
    pq->rear = p_new;  // 记录队尾指针，用新地址覆盖掉了 rear 的旧地址;
    pq->items++;       // pq队列的元素个数+1；
    return true;
}

bool DeQueue(Item *p_item, Queue * pq) {
    Node * tmp_node;
    if (QueueIsEmpty(pq)) {
        return false;
    }
    CopyToItem(pq->front, p_item); // 将待删除的节点的item，拷贝到传入地址中去
    tmp_node = pq->front->next; // 注意此处，在 EnQueue 时候，pq->rear->next = p_new 已经将 front 的 next 赋予了地址指向
    free(pq->front);
    pq->front = tmp_node;
    pq->items--;
    if (pq->items == 0) {
        pq->rear = NULL;
    }
    return true;
}

void EmptyQueue(Queue * queue) {
    Item dump;
    while (!QueueIsEmpty(queue)) {
        DeQueue(&dump, queue);
    }
}

void CopyToNode(Item item, Node * node) {
    node->item = item;
    node->next = NULL;
}

void CopyToItem(Node * pn, Item * pi) {
    *pi = pn->item;
}
```

主程序入口

```c
/* films3.c -- 使用抽象数据类型风格编写队列 */
#include <stdio.h>
#include <string.h>
#include "queue.h"

char * s_get(char *, int);

int main(void) {

    Queue line;
    Item temp;
    char ch;

    InitializeQueue(&line); // 初始化 line
    puts("Put 'a' to add mode, 'd' to delete mode, and put q to quit");
    while ((ch = getchar()) != 'q') {
        if (ch != 'a' && ch != 'd') {
            /* 忽略出了 a 和 d 以外的其他输出 */
            printf("the ch is %c, please input a or d\n", ch);
            continue;
        }
        if (ch == 'a') {
            printf("Input an integer to add queue: ");
            scanf("%d", &temp);
            if (!QueueIsFull(&line)) {
                printf("Putting %d to queue\n", temp);
                EnQueue(temp, &line);
            } else {
                puts("queue is full!");
            }
        } else {
            if (QueueIsEmpty(&line)) {
                puts("queue is empty, noting to delete");
            } else {
                DeQueue(&temp, &line);
                printf("delete %d from queue! \n", temp);
            }
        }
        while (getchar() != '\n')
            continue;
        printf("Now, %d items in queue \n", QueueItemCount(&line));
        puts("Put 'a' to add mode, 'd' to delete mode, and put q to quit");
    }

    EmptyQueue(&line);
    puts("free finished, bye");

    return 0;
}

char * s_get(char * str_ptr, int n) {
    char * ret_val;
    char * find;

    ret_val = fgets(str_ptr, n, stdin);
    if (ret_val) {
        find = strchr(str_ptr, '\n');
        if (find != NULL) {
            *find = '\0';
        } else {
            while (getchar() != '\n')
                continue;
        }
    }

    return ret_val;
}
```

代码输出

```
Put 'a' to add mode, 'd' to delete mode, and put q to quit
a
Input an integer to add queue: 1
Putting 1 to queue
Now, 1 items in queue 
Put 'a' to add mode, 'd' to delete mode, and put q to quit
a
Input an integer to add queue: 2
Putting 2 to queue
Now, 2 items in queue 
Put 'a' to add mode, 'd' to delete mode, and put q to quit
d
delete 1 from queue! 
Now, 1 items in queue 
Put 'a' to add mode, 'd' to delete mode, and put q to quit
q
free finished, bye
```

## 用队列进行模拟  

经过测试发现队列没有问题，现在做一些更多尝试   



