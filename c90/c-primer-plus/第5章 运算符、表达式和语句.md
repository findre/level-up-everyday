## 开篇实例
```c
#include "stdio.h"
#define ADJUST 7.31 // 明示常量

int main() {

    const double SCALE = 0.333; // const 只读常量
    double shoe, foot;

    shoe = 9.0; // 假设鞋码
    foot = SCALE * shoe + ADJUST;

    printf("Shoe size (men's) foot length\n");
    printf("%10.2f %15.2f inches\n", shoe, foot);

    return 0;
}
```
没啥可说的  
## while 循环
```c
#include "stdio.h"
#define ADJUST 7.31 // 明示常量，7.31

int main() {
    const double SCALE = 0.333; // const 只读常量
    double shoe, foot;

    printf("Shoe size (men's) foot length\n");
    shoe = 9.0;

    while (shoe < 18.5) // 这里不可加 ';' 
    {                   // 块 开始；while 的循环范围；
        foot = SCALE * shoe + ADJUST;
        printf("%6.2f %6.2f inches\n", shoe, foot);
        shoe = shoe + 1.0;
    }                   // 块 结束；

    printf("If the shoe fits, wear it\n");
    return 0;
}  
```
输出如下：

``` 
Shoe size (men's) foot length
 9.00  10.31 inches
 10.00  10.64 inches
 11.00  10.97 inches
 12.00  11.31 inches
 13.00  11.64 inches
 14.00  11.97 inches
 15.00  12.30 inches
 16.00  12.64 inches
 17.00  12.97 inches
 18.00  13.30 inches
If the shoe fits, wear it
```

## 几个术语
赋值表达式的目的是把值存储在内存位置上。
用于存储值的数据存储区域，统称为**数据对象（data object）**，**C**标准只有在提到这个概念时才会用到**对象**这个术语。使用变量名是标识对象的一种方法。**左值（lvalue）**是C语言的术语，用于标识特定数据对象的名称或者表达式。因此，**对象**指的是**实际的数据存储**，而**左值**是用于标识或定位存储位置的标签
早期C语言中，提到左值意味着：

1. 它指定一个对象，所以引用内存中的地址；
2. 它可用在赋值运算的左侧。

`const` 不满足上述第2点。  
后来因为业务需要与互联网发展，C语言新增了一个术语：**可修改的左值（modifiable lvalue）**  
**右值（rvalue）** 指的是能赋值给左值的量，且本身不是左值。`bmw = 2002;`  
**右值（rvalue）** 可以是常量、变量或其他可求值的表达式（如，函数调用）当前标准在描述这一概念时使用的是**表达式的值（value of an expression**），而不是右值。  
"=" 运算符的左侧运算对象应该是可修改的左值。  
  
### golf.c 程序
```c
/* golf.c -- 高尔夫锦标赛积分卡 */
#include "stdio.h"

int main() {
    int jane, tarzan, cheeta;
    cheeta = tarzan = jane = 68;
    printf("                  cheeta tarzan jane\n");
    printf("First round score %4d %8d %4d\n", cheeta, tarzan, jane);
    return 0;
}
```   
输出如下
```
                  cheeta tarzan jane
FIrst round score   68       68   68
```
许多其他程序会回避多重赋值，但是C语言没什么问题  

## 符号和运算符

加法 `sum = a + b;`  
减法 `sum = a - b;`  
减号可以让整数变为负数：  
```c
rocky = -12;
smokey = -rocky; // smokey 此时是 12
abc = +somkey; // 编译器不会宝错，但是以前的C标准规定这样做不允许
```  

## * 乘法运算符
```c
/* squares.c 计算 1 ～ 20 的平方 */
#include "stdio.h"

int main() {
    int num = 1;
    while (num < 21)
    {
        printf("%4d %6d\n", num, num * num);
        num = num + 1;
    }
    return 0;
}
```  
<br>  

### 乘法相关的指数增长
```c
/* wheat.c -- 指数增长 */
#include <stdio.h>
#define SQUARE 16 // 棋盘中的格子总数

int main() {
    const double CROP = 2E16; // 世界小麦年产谷粒数量
    double current, total;
    int count = 1;

    printf("square      grains      total      ");
    printf("fraction of \n");
    printf("            added       grains     ");
    printf("world total\n");
    total = current = 1.0;
    printf("%4d %13.2e %12.2ee %12.2e\n", count, current, total, total / CROP);
    while (count < SQUARE)
    {
        count = count + 1;
        current = 2.0 * current; // 下一个方格谷粒翻倍
        total = total + current;
        printf("%4d %13.2e %12.2ee %12.2e\n", count, current, total, total / CROP);
    }
    printf("That's all\n");
    return 0;
}
```
<br>  

程序输出如下  
```
square      grains      total      fraction of 
            added       grains     world total
   1      1.00e+00     1.00e+00e     5.00e-17
   2      2.00e+00     3.00e+00e     1.50e-16
   3      4.00e+00     7.00e+00e     3.50e-16
   4      8.00e+00     1.50e+01e     7.50e-16
   5      1.60e+01     3.10e+01e     1.55e-15
   6      3.20e+01     6.30e+01e     3.15e-15
   7      6.40e+01     1.27e+02e     6.35e-15
   8      1.28e+02     2.55e+02e     1.27e-14
   9      2.56e+02     5.11e+02e     2.55e-14
  10      5.12e+02     1.02e+03e     5.12e-14
  11      1.02e+03     2.05e+03e     1.02e-13
  12      2.05e+03     4.10e+03e     2.05e-13
  13      4.10e+03     8.19e+03e     4.10e-13
  14      8.19e+03     1.64e+04e     8.19e-13
  15      1.64e+04     3.28e+04e     1.64e-12
  16      3.28e+04     6.55e+04e     3.28e-12
That's all
```
<br>  

## / 除法运算符  

整数除法的结果是整数，截断小数部分。  
浮点数除法的结果是浮点数。  
所有语言都差不多 没什么可特殊学习的。  
除数与被除数数据类型应保持一致。
`printf("the result %.2f", 1.4 / 2)` 会输出 `0.7`  
一般情况下应避免上述写法，后边的2会被编译器处理为 2.0。  
<br>  

## 运算符优先级
` butter = 25.0 + 60.0 * n / SCALE; `  
语句的运算顺序是

1. 60.0 * n
2. / SCALE
3. \+ 25.0  

乘法/除法 > 加法/减法 > 左 > 右  

<br>  

