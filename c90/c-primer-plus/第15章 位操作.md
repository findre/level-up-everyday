# 按位操作
> ~、 &、 |、 ^、 >>、 <<、 &=、 |=、 ^=、 >>=、 <<=
> 二进制，十进制，十六进制计数法
> 位运算和位字段
> _Aligans、 _Alignof

C 语言可以单独操作变量的位，有时候这样做非常有用，比如协议、压缩以及密码等  
在硬件操作中也经常使用位来控制高低电压  

## 二进制数、位和字节

`2157 = 2 * 10^3 + 1 * 10^2 * 5 * 10^1 + 7 * 10^0`

说句不太科学的话，10进制之所以普及，是因为人类特么的只有 10 根手指头  
从某个方面看，计算机只有2根手指头，0 或 1，计算机使用2的幂而不是10的幂  
例如   
`1101 = 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0`  
以10进制表示为
`1 * 8 + 1 * 4 + 0 * 2 + 1 * 1 = 13`

### 二进制整数

通常一个字节包含8位，C语言用字节来描述存储系统所需要的字符集大小，它可能是9位，16位等  
但是描述存储芯片和传输率所用的字节指的是8位，为了简化，本章假设一个字节就是8位  

|位编号|7|6|5|4|3|2|1|0|
|-|-|-|-|-|-|-|-|-|
|位值|128|64|32|16|8|4|2|1|  

该字节能表示的最大数是 `128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255`  

或者通过不同的解释位组合，可以用来表示 -128 ~ +127 之间的整数，但是总量还是 256个

### 有符号的整数

如何表示有符号的整数取决于硬件，而不是C语言  

也许是用高阶位1位来存储符号，剩下的7位来存储数值  

这种符号量表示法又个缺点，就是会出现 +0 和 -0 的情况，容易混淆  

用2个值来表示也有空间浪费   

**二进制补码(two's-complement)** 方式避免了类似这样的问题, 是当今最常用的系统  

二进制补码使用1字节的后7位表示 0~127 高阶位至0  

如果高阶位是1，则表示为负数，两种方式的区别在于如何确定负值  

假如一个9位组合是 100000000（256的进制形式）减去一个负数位组合，结果是该负值的量  

比如128是 10000000，假如使用负值表示，则应该用 100000000 - 10000000 = 1000000（128）  

因此 该数是 -128，直接点，就是源码取反+1  

### 二进制浮点数

#### 二进制小数

`0.527 = 5 / 10 + 2 / 100 + 7 / 1000`

二进制小数中，使用2的幂作为分母  

所以二进制小数 .101 = 1/2^1 + 0/2^2 + 1/2^3

用十进制表示为 0.5 + 0.0 + 0.125 = 0.625

二进制小数，只能表示多个 1/2 的和  

因此 3/4 7/8 可以精确的使用二进制表示，但是 1/3 2/5 却不能  

这部分内容得靠课外阅读  


## 其他进制数

### 八进制

该系统基于8的幂，用0～7表示数字，例如八进制数 0451 表示为  

4 * 8<sup>2</sup> + 5 * 8<sup>1</sup> + 1 * 8<sup>0</sup> = 297(十进制)

**每个8进制位代表3个二进制位** 

|八进制|等价二进制|八进制|等价二进制|
|-|-|-|-|
|0|000|4|100|
|1|001|5|101|
|2|010|6|110|
|3|011|7|111|

例如 8进制 0377 的二进制表达是 `000011111111` 即 `111111111`  
一个3位的8进制 要用9位二进制来表示  

如果要用二进制代替8进制，则中间的0不能省略
例如 0173 的二进制表示是 `000001111011` 即 `1111011`

### 十六进制

该系统基于16的幂次方，用 `0～15` 表示数，但是由于没有单独的数能表示 `10～15`  

因此16进制中，用 `A~F` 来表示 `10～15`

例如16进制数 `A3F` 代表 10 * 16<sup>2</sup> + 3 * 16<sup>1</sup> + 15 * 16<sup>0</sup> = 2623 (十进制)  

也可以写作 `0xa3f`

每个16进制位代表4个二进制位，和8进制类似的逻辑  

因此 `11010101 = 1101 0101 = D5 = 0xd5`

|十进制|十六进制|等价二进制|十进制|十六进制|等价二进制|
|-|-|-|-|-|-|
|0|0x00|0000|8|0x08|1000|
|1|0x01|0001|9|0x09|1001|
|2|0x02|0010|A|0x0a|1010|
|3|0x03|0011|B|0x0b|1011|
|4|0x04|0100|C|0x0c|1100|
|5|0x05|0101|D|0x0d|1101|
|6|0x06|0110|E|0x0e|1110|
|7|0x07|0111|F|0x0f|1111|

没啥可说的 参阅《深入理解计算机系统》csapp 吧  

## C 按位运算符

一般不用二进制写代码，但是计算机底层就是特娘的二进制  

### 按位逻辑运算  

#### 二进制反码或二进制取反 `～`  

`
~(10101101) = 01010010
`
假设有 `unsigned char val = 2` 也就是说 `val == 00000010`  
那么 `~val == 11111101` 也就是 253 

#### 按位与 `&`、`&=` 

`10110111 & 10001101 == 10000101`  

只有 2 个值都为 1 时，结果才位 1  

通过 `&=` 可以进行 赋值结合运算 `val &= 10111101`

#### 按位或 `|` 

`10110111 | 10001101 == 10111111`  

也可以使用 `|=` 同时赋值

#### 按位异或 `^`

只有 1 与 0 组合 ，结果才为 1 不然为 0  

`11100010 ^ 01011110 == 10111100`

也可以使用 `^=` 同时赋值

### 行为：掩码

所谓掩码，指的是一些设置为 开(1) 或 关(0) 的位组合，要明白称其为掩码的原因  

假设定义符号常量 `MASK` 为 2 即 `00000010`，只有1号位是1, 其他都是0    

语句 `flags = flags & MASK;` 把 flags 中除了1号位以外的所有位都设置为0，这个过程被称为**使用掩码**  

可以这样类别：把除了1号以外的值都用0进行掩盖，不透明（无法知道flags那一位究竟是什么）   

只有1号位透明，其他位不透明。

可以用 00000000 掩盖一切你想掩盖的位

### 行为：打开位（设置位）

所谓打开位，就是指你想通过位操作将某一位的值至为1，其他位的值不变  

这在硬件交互时可能会用到，主要处理逻辑其实与 掩码行为类似，只不过需要用到  `|`  

`(00001111) |= (10110110)` 打开 |= 后边的 1 位

`10111111` 结果

### 行为：关闭位（清空位）

所谓关闭位，就是指你想通过位操作将某些位的值至为0，其他位的值不变  

这在硬件交互时可能会用到，主要处理逻辑其实与 打开位行为类似，只不过需要用到  `&`  

`(00001111) &= (10110110)` 关闭 &= 后边的 1 位

`00000110` 结果

### 行为：切换位

所谓切换位，就是打开已关闭的，关闭已打开的  

需要用到 `^` 异或操作符

```
1 ^ 1 = 0
0 ^ 1 = 1
1 ^ 0 = 1
0 ^ 0 = 0
```

因此使用 `^1` 可以对对应位进行切换位操作, 针对不想切换的位， `^0` 即可维持原值

### 行为：检查位的值

有时候需要检查某些位是否已经打开。或者已经关闭。需要 用到 `&` 进行过滤，此处不涉及到赋值  

比如 flags = 10101010 想要检查倒数第2位是否为1 可以  

`(flags & 00000010) == 00000010` 来判断  

### 移位运算符

左移运算符 `<<` 让位向左移动，左侧溢出部分会丢失，右侧会用0填充

`128 << 1 == 256` 左移操作是读，新写操作，不改变左侧值本身， 可以使用 <<= 来代替其本身  

右移操作涉及符号，无符号用 0 向左填充

有符号类型取决于机器本身  

`(10001010 >> 2) -> 00100101 // 有些机器`
`(10001010 >> 2) -> 11100010 // 有些机器`

number << 2 number 无符号, 代表 number * 2<sup>2</sup>
number >> 2 number 无符号, 代表 number / 2<sup>2</sup>

颜色 unsigned long rgb : (红：255, 绿：255, 蓝：255) 表示 00000000 11111111 11111111  

### 编程实例

itobs() 函数可以将整数转化为 二进制字符

上代码  
```c
/* bin_bit.c -- 使用位操作显示二进制 */
#include <stdio.h>
#include <limits.h> // 提供 CHAR_BIT 定义，CHAR_BIT 代表每个字节的位数

char * int_to_binaries(int, char *);
void show(char *);

int main(void) {
    char bit_str[CHAR_BIT * sizeof(int) + 1]; // macOS 此时值 == 33, 8 * 4 + 1
    int number;
    puts("> INFO | ENTER the int");
    while (scanf("%d", &number) == 1) {
        int_to_binaries(number, bit_str);
        printf("%d is ", number);
        show(bit_str);
        putchar('\n');
    }
    return 0;
}

char * int_to_binaries(int number, char * str) {
    int i;
    // CHAR_BIT = 8 代表系统中一个字节有8位
    // sizeof(int) = 4 代表系统中int类型占4字节
    const static int size = CHAR_BIT * sizeof(int);
    // 00000001 & number 就是要看它最后一位是0或1，也可以简写为 0x01(16进制) 或 者01(8进制)
    // int + '0' 可以将 int 类型转化为对应的字符类型
    // number 无符号 一直在右移
    for (i = size - 1; i >= 0; i--) {
        str[i] = (00000001 & number) + '0';
        number >>= 1;
    }
    str[size] = '\0';
    return str;
}

void show(char * str) {
    int i = 0;
    while (str[i]) {
        putchar(str[i]);
        if (++i % 8 == 0) {
            putchar(' ');
        }
    }
}
```
代码输出
```
> INFO | ENTER the int
8
8 is 00000000 00000000 00000000 00001000 
123
123 is 00000000 00000000 00000000 01111011 
1234567
1234567 is 00000000 00010010 11010110 10000111
```

再看一个例子

切换一个值中的后n位
```c
/* invert4.c -- 使用位操作显示二进制 */
#include <stdio.h>
#include <limits.h> // 提供 CHAR_BIT 定义，CHAR_BIT 代表每个字节的位数

char * int_to_binaries(int, char *);
int invert_end(int, int);
void show(char *);

int main(void) {
    char bit_str[CHAR_BIT * sizeof(int) + 1]; // macOS 此时值 == 33, 8 * 4 + 1
    int number;
    puts("> INFO | ENTER the int");
    while (scanf("%d", &number) == 1) {
        int_to_binaries(number, bit_str);
        printf("%d is ", number);
        show(bit_str);
        putchar('\n');
        number = invert_end(number, 4);
        int_to_binaries(number, bit_str);
        printf("%d invert is ", number);
        show(bit_str);
        putchar('\n');
        printf("> INFO | Inverting last 4 bits gives %d\n", number);
    }
    return 0;
}

char * int_to_binaries(int number, char * str) {
    int i;
    // CHAR_BIT = 8 代表系统中一个字节有8位
    // sizeof(int) = 4 代表系统中int类型占4字节
    const static int size = CHAR_BIT * sizeof(int);
    // 00000001 & number 就是要看它最后一位是0或1，也可以简写为 0x01(16进制) 或 者01(8进制)
    // int + '0' 可以将 int 类型转化为对应的字符类型
    // number 无符号 一直在右移
    for (i = size - 1; i >= 0; i--) {
        str[i] = (00000001 & number) + '0';
        number >>= 1;
    }
    str[size] = '\0';
    return str;
}

void show(char * str) {
    int i = 0;
    while (str[i]) {
        putchar(str[i]);
        if (++i % 8 == 0) {
            putchar(' ');
        }
    }
}

int invert_end(int num, int bits) {
    int mask = 0;    // 00000000
    int bit_val = 1;
    while (bits-- > 0) {
        mask |= bit_val;
        bit_val <<= 1; // 按位放置 1
    }
    return num ^ mask;
}
```
代码输出
```
> INFO | ENTER the int
1234
1234 is 00000000 00000000 00000100 11010010 
1245 invert is 00000000 00000000 00000100 11011101 
> INFO | Inverting last 4 bits gives 1245
```

## 位字段

操控位的2种方式是位字段  

位字段是一个 signed int 或 unsigned int 位字段通过一个结构声明来建立  

比如 

```c
struct {
    unsigned int autfd: 1;
    unsigned int bldfc: 1;
    unsigned int undln: 1;
    unsigned int itals: 1;
} prnt;
```
该声明表示  prnt 还有 4个位为1的字段















