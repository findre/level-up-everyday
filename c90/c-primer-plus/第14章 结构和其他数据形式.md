# 结构和其他数据形式

+ 关键字：struct、union、typedef  
+ 运算符：.、->
+ 创建结构模版和结构变量
+ 如何访问结构成员、如何编写处理结构的函数
+ 联合指向函数的指针

## 示例问题：创建图书目录结构

直接上代码

```c
/* book.c -- 一本图书的目录结构 */
#include <stdio.h>
#include <string.h>

char * s_get(char * str, int size);

#define MAX_TITLE 41  // 数名最大长度为 40
#define MAX_AUTHOR 31 // 作者名最大长度为 30

struct book {
    char title[MAX_TITLE];
    char author[MAX_AUTHOR];
    float value;
};

int main(void) {

    struct book library; // 声明 library 为 一本书

    puts("> INFO | Enter the book title");
    s_get(library.title, MAX_TITLE);

    puts("> INFO | Enter the book author");
    s_get(library.author, MAX_AUTHOR);

    puts("> INFO | Enter the book value");
    scanf("%f", &library.value);

    printf("> INFO | \"%s\" by %s, cost $%.2f\n", library.title, library.author, library.value);
    puts("Done");

    return 0;
}

char * s_get(char * str, int size) {
    char * ret_val;
    char * find;
    ret_val = fgets(str, size, stdin);
    if (ret_val) {
        find = strchr(str, '\n'); // 查找是否有 \n， size前提前回车
        if (find) {                    // 如果有 将 \n 替换为 \0
            *find = '\0';
        } else {
            while (getchar() != '\n')  // 清空输入缓冲区
                continue;
        }
    }
    return ret_val;
}
```

代码输出 

```
> INFO | Enter the book title
望春风
> INFO | Enter the book author
格非
> INFO | Enter the book value
23.9
> INFO | "望春风" by 格非, cost $23.90
Done
```

<br>  

## 建立结构声明

结构体声明 (structure declaration) 描述了结构的组织布局，类似:  
```c
struct book {
    char title[41];
    char author[31];
    float cost;
}
```
该结构题并为创建实际的数据对象，只是描述了对象由什么组成  

有时，我们把结构声明称为**模版**，此模版非彼模版，C++ 中的模版更为强大  

`book` 跟在 `struct` 关键字后，是一个可选标记。

<br>  

## 定义结构变量

结构有2层含义，一层是结构布局，该布局告诉编译器如何表述数据，但是不让编译器分配空间  

下一步是创建结构变量，`struct book library` 

编译器会通过 `book` 模版为 `library` 分配空间  

声明多个以及一个指针: `strcut book, panshin, *pt_book`  

结构体的内存分配应该遵循内存的数据布局，可以作为拔高方向修炼  

结构体也可以进行块儿内部的临时声明，比如  

```c
struct book {
    char title[41];
    char author[31];
    float value;
} library; // 花括号紧跟变量名
```

### 初始化结构

```c
struct book library = {
    "The book title",
    "The book author",
    28.2
}
```

类似这样直接初始化, `golang` 也是如此 

### 访问结构成员

结构体类似一个**超级数组**  
使用 `.` 来访问这个数据中的数据, 比如 `book.title`，这相当于使用下标访问数据  

### 结构的初始化器

C99 和 C11 为结构体提供了 **指定初始化器 (designated initialzer)**  

其语法与数组的指定初始化器类似, 

`struct book surprise = { .value = 99 };`

`struct book gift = { .value = 25.99, .author = "Johnny" }`


<br>  

## 结构数组

扩展开篇例子，让它处理多本书

```c
/* book.c -- 一本图书的目录结构 */
#include <stdio.h>
#include <string.h>

char * s_get(char * str, int size);

#define MAX_TITLE 41  // 数名最大长度为 40
#define MAX_AUTHOR 31 // 作者名最大长度为 30
#define MAX_DOCS 100  // 书籍最大数量

struct Doc {
    char title[MAX_TITLE];
    char author[MAX_AUTHOR];
    float value;
};

int main(void) {
    struct Doc library[MAX_DOCS]; // book 类型的结构体数组
    int count = 0;
    int index;

    /* 持续输入书籍信息 */
    printf("> INFO | Enter the %d book info\n", count);
    while (count < MAX_DOCS && s_get(library[count].title, MAX_TITLE) != NULL && library[count].title[0] != '\0') {
        printf("> INFO | Enter the %d author\n", count);
        s_get(library[count].author, MAX_AUTHOR);
        printf("> INFO | Enter the %d cost\n", count);
        scanf("%f", &library[count++].value);
        while (getchar() != '\n')
            continue;
        if (count < MAX_DOCS)
            printf("> INFO | Enter the Next %d book info\n", count);
    }

    if (count > 0) {
        puts("===================================");
        printf("> INFO | Here this the book list\n");
        for (index = 0; index < count; index++) {
            printf("> INFO | the \"%s\" by %s, cost $%.2f\n", library[index].title, library[index].author, library[index].value);
        }
    }

    return 0;
}

char * s_get(char * str, int size) {

    char * ret_val;
    char * find;

    ret_val = fgets(str, size, stdin);
    if (ret_val) {
        if ((find = strchr(str, '\n')) != NULL) {
            *find = '\0';
        } else {
            while (getchar() != '\n')
                continue;
        }
    }
    return ret_val;
}
```

代码输出

```
> INFO | Enter the 0 book info
JohnnyLeaf's A
> INFO | Enter the 0 author
Johnny
> INFO | Enter the 0 cost
12.1
> INFO | Enter the Next 1 book info
JohnnyLeaf's B
> INFO | Enter the 1 author
Johnny
> INFO | Enter the 1 cost
13.2
> INFO | Enter the Next 2 book info
===================================
> INFO | Here this the book list
> INFO | the "JohnnyLeaf's A" by Johnny, cost $12.10
> INFO | the "JohnnyLeaf's B" by Johnny, cost $13.20
```

感觉没啥可说的

<br>  

### 声明结构数组与标识结构数组的成员

`library` 本身并不是结构名 而是一个数组名, 该数组的每个成员变量都是一个 `book` 类型

```c
library[0].value // 正确
library.value[0] // 错误
```

### 程序分析

其实没啥可分析的  

```c
scanf("%f", &library[count].value)
while(getchar() != '\n')
    continue;
```

这里是为了将用户输入的 `\n` 消掉  

scanf 会读出用户输入的浮点, 但是保留 `\n` 在 stdin 中

<br>  

## 嵌套结构

上代码

```c
/* friend.c -- 嵌套结构事例 */
#include <stdio.h>
#define LEN 20

const char * msgs[5] = {
        "    Thank you for everything wonderful evening, ",
        "You certainly prove that a ",
        "is a special kind of guy, We must get together",
        "over a delicious ",
        " and hava a few laughs"
};

struct names {
    char first[LEN];
    char last[LEN];
};

struct guy {
    struct names handle;
    char gav_food[LEN];
    char job[LEN];
    double income;
};

int main(void) {

    struct guy fellow = {
            {"Johnny", "Leaf"},
            "grilled salmon",
            "personality coach",
            68112.9
    };

    printf("Dear %s, \n\n", fellow.handle.first);
    printf("%s%s.\n", msgs[0], fellow.handle.first);
    printf("%s%s\n", msgs[1], fellow.job);
    printf("%s\n", msgs[2]);
    printf("%s%s%s", msgs[3], fellow.gav_food, msgs[4]);

    if (fellow.income > 15000.0) {
        puts("!!");
    } else if (fellow.income > 75000.0) {
        puts("!");
    } else {
        puts(".");
    }

    printf("\n%40s%s\n", " ", "See you soon");
    printf("%40s%s\n", " ", "Chloe");

    return 0;
}
```
代码输出
```
Dear Johnny, 

    Thank you for everything wonderful evening, Johnny.
You certainly prove that a personality coach
is a special kind of guy, We must get together
over a delicious grilled salmon and hava a few laughs!!

                                        See you soon
                                        Chloe
```

## 指向结构的指针

骚年你喜欢指针吗？    
  
喜欢！  

为啥要用结构指针？

1. 指向数组的指针，相比数据本身更容易操控（如排序问题），指向结构的指针同理  
2. 早期C语言中，结构体不能作为参数进行传递，但是可以传递指针结构
3. 相比传递结构，传递指针更有效率
4. 一些结构体中的成员对象有可能是指向其他地址的指针

上代码

```c
/* friends.c -- 使用指针指向数据结构 */
#include <stdio.h>
#define LEN 20

const char * msgs[5] = {
        "    Thank you for everything wonderful evening, ",
        "You certainly prove that a ",
        "is a special kind of guy, We must get together",
        "over a delicious ",
        " and hava a few laughs"
};

struct names {
    char first[LEN];
    char last[LEN];
};

struct guy {
    struct names handle;
    char gav_food[LEN];
    char job[LEN];
    double income;
};

int main(void) {

    struct guy fellow[2] = {
            {
                    {"Johnny", "Leaf"},
                    "grilled salmon",
                    "personality coach",
                    68112.9
            },
            {
                    {"Chloe", "Bi"},
                    "tripe",
                    "tabloid editor",
                    432400.00
            }
    };

    struct guy * him;

    printf("> INFO | address #1: %p, #2: %p\n", &fellow[0], &fellow[1]);
    him = &fellow[0];
    printf("> INFO | pointer #1: %p, #2: %p\n", him, him+1);
    printf("> INFO | him income is $%.2f, (*him).income is %.2f \n", him->income, (*him).income);
    him++; // 指向下一个结构体
    printf("> INFO | him income is $%.2f, (*him).income is %.2f \n", him->income, (*him).income);

    return 0;
}
```
代码输出
```
> INFO | address #1: 0x7ff7b6e64220, #2: 0x7ff7b6e64278
> INFO | pointer #1: 0x7ff7b6e64220, #2: 0x7ff7b6e64278
> INFO | him income is $68112.90, (*him).income is 68112.90 
> INFO | him income is $432400.00, (*him).income is 432400.00
```

与操作数组类似

### 声明和初始化结构指针

`struct guy * him;` 首先声明是 `struct` 然后紧跟标识 `guy` 然后是 `* him`  

该声明并未创建任何新的结构，而是告诉编译器，`him` 可以指向任意一个 `guy` 的地址  

和数组不同的是，结构名并不是结构地址。需要用到 `&` 运算符  

通过上面的结果，可以计算出结构体占用的内存大小。#2 - #1 = 88 字节  
正好是`(4 * sizeof(char) * 10) + (1 * sizeof(double))`

在某些系统中，计算出的大小可能比 88要大，因为系统对数据进行校准的过程中产生了‘缝隙’   

例如有些系统中，成员对象的地址必须放在'偶数'地址中  

### 用指针访问成员

最常用的方法是使用 `->`
```c
him->income;
```
如果 `him = &barney` 那么 `him->income` 即是 `barney.income`  

如果 `him = &barney[0]` 那么 `him->income` 即是 `barney[0].income`

由于 . 运算符优先级比 * 运算符高，所以 `(*him).income == barney[0].income` 要加 `()`

<br>  

## 向函数传递结构体信息

由于结构体比单纯的值更复杂，因此以前的C不允许传递结构体。  
ANSI C 之后取消了这个限制

### 传递结构成员

上代码

```c
/* funds1.c -- 把结构成员作为参数传递 */
#include <stdio.h>
#define FUND_LEN 32

struct funds {
    double bank_found;
    double save_found;
    char bank[FUND_LEN];
    char save[FUND_LEN];
};

double sums(double, double);

int main(void) {
    struct funds stan = {
            123.45,
            25.13,
            "中国建设银行",
            "中国招商银行"
    };
    printf("Stan has a total of $%.2f.\n", sums(stan.bank_found, stan.save_found));
    return 0;
}

double sums(double x, double y) {
    return x + y;
}
```

代码输出

```
Stan has a total of $148.58.
```

好像又没啥可说的

### 传递结构地址


