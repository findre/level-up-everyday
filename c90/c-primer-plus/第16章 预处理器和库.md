# C预处理器和C库

> 预处理指令：#define #include #ifdef #else #endif #ifndef #if #elif #line #error #program  
> 关键字：_Generic, _Noreturn, _Static_assert  
> 函数/宏 sqrt(), atan(), atan2()、exit()、atexit()、assert()、memcpy()、memmove() ...  
> C预处理器的其他功能  
> 通用选择表达式  
> 内联函数  
> C库概述和一些特殊方法  

C 标准不仅描述C语言，也描述预处理器、C标准库有哪些函数、以及这些函数的工作原理  

<br>

# 翻译的第一步

1) 预处理之前，编译器必须对程序进行一些翻译处理，首先编译器会把代码中出现的一些字符，映射到原始字符集  
该过程处理 **多字节字符** 和 **三字符序列** 字符扩展让C更加国际化  

2) 然后，编译器定位每个 \ 后面跟着换行符的实例，并删除它们，比如把下面两个物理行删减位一个逻辑行  
    ```c
    printf("hello \
    world.")
    ```   
    一个逻辑行可以是多个物理行  
  
3) 之后，编译器把文本划分成**预处理记号序列**、**空白序列**和**注释序列**  
 记号是由空格、制表符和换行符分割的项，详见16.2.1
 比如
    ```c
    int /*这里将会被分割*/ fox;
    // 将变成
    int fox;
    ```

4) 程序已经做好预处理准备，预处理器开始查找一行中以`#`开头的预处理指令  

<br>

## 明示常量  #define

每行 #define 由 3部分组成 

1) `#define` 指令本身
2) 选定的缩写，也称为 ‘宏’，不允许有空格，必须遵循C语言命名标准
3) 替换列表或替换体，预处理器一点找到改宏名，将用替换体代替该宏

宏替换的过程被称为**宏展开（macro expansion）**

宏可以是特定的值，或者是表达式  

```c
/* pre_proc.c -- 简单使用预处理 */
#include <stdio.h>
#define TWO 2
#define OW "Consistency is the last refuge of the unimaginative.\
- Oscar Wilde" /* 反斜杠将该定义延续到下一行 注意这里要对齐 */

#define FOUR TWO * TWO
#define PX printf("X is %d.\n", x)
#define FMT "X is %d.\n"

int main(void) {
    /* 宏展开 */
    int x = TWO;
    PX;
    x = FOUR; /* TWO * TWO 不是 4 */
    /* 宏展开到此为止 */
    printf(FMT, x);
    printf("%s\n", OW);
    printf("TWO: OW\n");
    return 0;
}
```
代码输出
```
X is 2.
X is 4.
Consistency is the last refuge of the unimaginative. - Oscar Wilde
TWO: OW
```
**预处理器不会进行实际的乘法运算，乘法运算是在编译期完成的**
**预处理也不会对表达式进行求值，也是在编译期完成，预处理只进行简单的替换**

宏定义可以嵌套其他宏（一些编译器不支持）  

那么何时使用字符串常量？
1. 绝大部分数字常量，应该用字符常量
2. 数字是 EOF 等系统代码

关于 const 关键字：
```c
#define LIMIT 20
const int LIM = 50;
static int data1[LIMIT]; // 有效
static int data2[LIM];   // 无效
const int LIM2 = LIMIT * 2 // 有效
const int LIM3 = LIM * 3 // 无效
```

在C语言中，非自动大小的数组，应该是整型常量表达式  

1. 类似 5 这样的整形
2. 枚举值
3. sizeof表达式返回值

这也是C和C++的区别，C++会把 cosnt 也当作常量表达式  

### 记号

从技术角度看，可以把宏的替换体看作是记号（token）型字符串，而不是字符型字符串，  
```c
#define FOUR 2*2
```
C预处理器记号，是宏替换体中单独的词，比如上述的 `2*2`  
但是下面的宏定义:
```c
#define FOUR 2 * 2
```
有3个记号。分别是 2、*、2  
当替换体中有多个空格时，记号型字符串和字符型字符串的处理方式不同
```c
#define EIGHT 4 * 8
```
如果预处理器把该替换体解释为字符型字符串，则把 4 * 8 替换EIGHT，即额外的空格是替换体的一部分  

如果预处理器把替换体解释为记号型字符串，则把 4 * 8 分为3个记号来替换EIGHT  

再实际应用中，一些C编译器会把替换体解释为字符型字符串

C编译器相比预处理器更加负责，由于编译器理解C语言规则  
因此不要求代码中的空格来分割记号，C编译器可以把2*2分割成3个记号，他能识别 2，也能识别运算符 *  

### 重定义常量

将已经定义好 #define SIZ = 2 * 2 修改 为 #define SIZ = 2*2 是不行的

因为 前一个替换体有3个记号，后一个替换体只有1个记号  

替换前要先 #undef （后边介绍）  

## 在#define中使用参数

直接上代码

```c
/* mac_arg.c -- 带参数的宏 */
#include <stdio.h>

#define SQUARE(x) x*x
#define PR(X) printf("The result is %d.\n", X)

int main(void) {
    int x = 5;
    int z;
    printf("x = %d\n", x);
    z = SQUARE(x);
    printf("Evaluating SQUARE(x): ");
    PR(z);
    z = SQUARE(2);
    printf("Evaluating SQUARE(2): ");
    PR(z);
    printf("Evaluating SQUARE(x+2): "); // 出问题了！
    PR(SQUARE(x+2));
    printf("Evaluating 100/SQUARE(2): "); // 出问题了！
    PR(100 / SQUARE(2));
    printf("x is %d\n", x);
    printf("Evaluating SQUARE(++x): "); // 出问题了！
    PR(SQUARE(++x));
    printf("After incrementing x is %x.\n", x);
    return 0;
}
```
代码输出
```
x = 5
Evaluating SQUARE(x): The result is 25.
Evaluating SQUARE(2): The result is 4.
Evaluating SQUARE(x+2): The result is 17.
Evaluating 100/SQUARE(2): The result is 100.
x is 5
Evaluating SQUARE(++x): The result is 42.
After incrementing x is 7.
```

可以看到 SQUARE(x+2) 的结果是17, 因为 `5+2*5+2=17`,

**预处理器不参与计算！只替换！！**

如果想让 `SQUARE(x+2)=49` 则需要给宏替换体增加括号 `(x) * (x)` 来规范运算优先级  

但是这样并没有解决所有问题  

`PR(100/SQUARE(2))` 的运算顺序是 `100 / (2) * (2)` 结果仍然等于 100，这不符合预期

如果想让 `100/SQUARE(2)=25` 则需要继续给宏替换体增加括号 `((x) * (x))`  

但是你以为这样就结束了吗？  

`SQUARE(++x)` 变成了 `((++x) * (++x))` 宏展开带入宏参数得 `6*7=42`  

有些编译器在计算乘法之前做了 `++` 运算，得到 36，有些则不然，比如我们的 gcc  

因此不要给任何函数传递 `++` 个人认为是一种好习惯  

### 用参数创建字符串 #运算符  

如果x是一个宏形参，那么#x就是转化字符串“x”的形参数名

上代码 

```c
/* sub_str.c -- 在字符串中替换 */
#include <stdio.h>
#define PSQR(x) printf("The square of "#x" is %d\n", ((x) * (x)))

int main(void) {
    int y = 5;
    PSQR(y);
    PSQR(2 + 4);
    return 0;
}
```
代码输出
```
The square of y is 25
The square of 2 + 4 is 36
```

`#x` 可以将数字替换为字母

### 预处理器粘合剂：##运算符

与#运算符类似，`##`运算符可用于类函数宏的替换部分，`##`还可用于对象宏的替换部分  

上代码

```c
/* glue.c -- 使用 ## 运算符 */
#include <stdio.h>
#define X_NAME(n) x ## n
#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n); // #n 完成字符串粘贴

int main(void) {
    int X_NAME(1) = 14; // 变成 int x1 = 14
    int X_NAME(2) = 20; // 变成 int x2 = 20
    int x3 = 30;        // x3 = 30

    PRINT_XN(1) // 变成 printf("x1=%d\n", x1)
    PRINT_XN(2)
    PRINT_XN(3)

    return 0;
}
```

代码输出

```
x1 = 14
x2 = 20
x3 = 30
```

这在逻辑运行前，预处理进行代码复用，预处理器NB

### 变参宏 ... 和 VA_ARGS

一些函数( printf() ) 接受数量可变的参数，`stdvar.h` 头文件中有需要的工具  

C99/C11 也提供类类似的工具，虽然C标准中未使用 “可变” 这个词  

通过把宏参数列表的参数写成 `...` 来完成可变传参的目标 

预定义宏 `__VA_ARGS__` 可用在替换部分中，表明省略号代表什么  

直接上代码 

```c
/* variadic.c -- 变参宏 */
#include <stdio.h>
#include <math.h>
#define PR(X, ...) printf("Message, "#X": "__VA_ARGS__)

int main(void) {
    double x = 48;
    double y;
    y = sqrt(x);
    PR(1, "x = %g\n", x);
    PR(2, "x = %.2g, y = %.4f\n", x, y);
    return 0;
}
```
代码输出
```
Message, 1: x = 48
Message, 2: x = 48, y = 6.9282
```

我个人不喜欢这样的写法

<br>  

## 宏和函数的选择

宏相比函数更加复杂，稍有不慎就会产生奇怪的错误  

**一些编译器规定宏只能定义成一行**

宏和函数是时间和空间的权衡，宏生成内联代码，即在程序中生成语句  

如果调用20次宏，既在程序中插入20行代码  

如果调用函数20次，程序中只有一份函数语句的副本，所以节省了空间 

然而另一方面，程序的执行必须进入程序内部，最后必须返回主调函数，这无形中增加了耗时  

宏的另一个有点是不用担心变量类型 `int` 或者 `float` 都能用 `SQUARE(x)` 宏

C99 提供了 3 种 可替换的方法 “内联函数”  

对于简单的函数，用宏可以更快的解决问题 

```c
#define MAX(x, y) ((x) > (y) ? (x) : (y))
#define ABS(x, y) ((x) < 0 ? (-x) : x)
#define ISSIGN(x) ((x) == '+' || (x) == '-' ? 1 : 0)
```

注意事项：
1. 宏名称中不能有空格，但是在替换字符串中可以有空格，ASIN C 允许在参数列表中有空格。 
2. 宏中用括号将宏参数扩起来，能够更正确的进行宏展开
3. 用大写字母表示宏函数更加通用，同时提醒程序猿这是tmd宏
4. 使用宏之前需要明确，和函数相比，宏是否会产生以外错误  

所以那几 us 值得用宏么  

<br>  

## 文件包含 #include 指令

预处理器在发现 #include 指令时，会把包内用引用到当前文件夹  

这相当于把被包含的文件内容，输入到原始文件中  

```c
#include <stdio.h>
#include "mystuff.h"
#include "/usr/biff/p.h"
```

**尖括号告诉预处理器在标准系统目录中查找文件**  
**双引号告诉预处理器现在当前目录查询，如果没有，再去标准目录**  

不同的编译器查找的方式也可能略有不同，不过不重要。  

头文件一般也会包含一部分预处理指令，以及函数的实现。 

包含一个大型的头文件不一定会显著的增加程序大小，再大部分情况下  
头文件内容是编译器生成最终代码时候需要的信息，而不是添加到最终代码中的材料  

<br>  


### 头文件示例

`names_st.h`:
```c
/* names_st.h -- names_st 头文件 */
#include <stdio.h>

// 常量声明
#define NAME_MAX_L 32

// 结构声明
struct names_st {
    char first[NAME_MAX_L];
    char last[NAME_MAX_L];
};

// 类型定义声明
typedef struct names_st names;

// 函数原型声明
void get_names(names *);
void show_names(const names *);
void * s_get(char * str, int n);
```
`names_st.c`:
```c
/* names_st.c -- 实现 names_st.h 头声明 */
#include <string.h>
#include "names_st.h"

// 函数定义
void get_names(names * pn) {
    printf("Input first: \n");
    s_get(pn->first, NAME_MAX_L);

    printf("Input last: \n");
    s_get(pn->last, NAME_MAX_L);
}

void show_names(const names * ptn) {
    printf("%s %s", ptn->first, ptn->last);
}

void * s_get(char * str, int n) {
    char * ret_val;
    char * find;
    ret_val = fgets(str, n, stdin);
    if (ret_val) {
        find = strchr(str, '\n');
        if (find) {
            *find = '\0'; // 将对应字段改为 结束符
        } else {
            while (getchar() != '\n')
                continue; // 处理缓冲区中的剩余字符
        }
    }
    return ret_val;
}
```
`main.c`:
```c
/* use_header.c -- 使用 names 结构 */
#include <stdio.h>
#include "names_st.h"

int main(void) {
    names candidate;
    get_names(&candidate);
    printf("welcome ");
    show_names(&candidate);
    printf(" to here\n");
    return 0;
}
```

编译时候需要同时编译 main.c 和 names_st.c 两个文件生成一个程序 

```shell
gcc -o prog -Wall main.c names_st.c
```

### 使用头文件

常见的头文件内容如下  

- 明示常量 ---- 例如 `stdio.h` 中 `EOF`, `NULL` 和 `BUFFERSIZE`（标准IO缓冲区大小）
- 宏函数 ---- 例如 `getc(stdin)` 通常用 `getchar()` 定义，而 `getc()` 通常用于定义较为复杂的宏
- 函数声明 ---- 例如 `string.h` 头文件（一些旧系统中是 strings.h）
- 结构模版定义 ---- 标准 IO 使用的 `FILE` 结构
- 类型定义 ---- `typedef`
- 外部声明 ---- `extern xxxx`
- 使用具有文件作用域、内部链接和 const限定符的变量后者数组

还可以使用头文件声明外部文件供其他文件共享 
```c
int status = 0;
```
在头文件中：
```c
extern int status; // 在头文件中，声明使用外部
```

<br>  

## 其他指令 

`#define` - 生成可及时使用的代码
`#undef` - 取消之前的 `#define` 定义的内容
