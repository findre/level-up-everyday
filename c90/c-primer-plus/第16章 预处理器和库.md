# C预处理器和C库

> 预处理指令：#define #include #ifdef #else #endif #ifndef #if #elif #line #error #program  
> 关键字：_Generic, _Noreturn, _Static_assert  
> 函数/宏 sqrt(), atan(), atan2()、exit()、atexit()、assert()、memcpy()、memmove() ...  
> C预处理器的其他功能  
> 通用选择表达式  
> 内联函数  
> C库概述和一些特殊方法  

C 标准不仅描述C语言，也描述预处理器、C标准库有哪些函数、以及这些函数的工作原理  

<br>

# 翻译的第一步

1) 预处理之前，编译器必须对程序进行一些翻译处理，首先编译器会把代码中出现的一些字符，映射到原始字符集  
该过程处理 **多字节字符** 和 **三字符序列** 字符扩展让C更加国际化  

2) 然后，编译器定位每个 \ 后面跟着换行符的实例，并删除它们，比如把下面两个物理行删减位一个逻辑行  
    ```c
    printf("hello \
    world.")
    ```   
    一个逻辑行可以是多个物理行  
  
3) 之后，编译器把文本划分成**预处理记号序列**、**空白序列**和**注释序列**  
 记号是由空格、制表符和换行符分割的项，详见16.2.1
 比如
    ```c
    int /*这里将会被分割*/ fox;
    // 将变成
    int fox;
    ```

4) 程序已经做好预处理准备，预处理器开始查找一行中以`#`开头的预处理指令  

<br>

## 明示常量  #define

每行 #define 由 3部分组成 

1) `#define` 指令本身
2) 选定的缩写，也称为 ‘宏’，不允许有空格，必须遵循C语言命名标准
3) 替换列表或替换体，预处理器一点找到改宏名，将用替换体代替该宏

宏替换的过程被称为**宏展开（macro expansion）**

宏可以是特定的值，或者是表达式  

```c
/* pre_proc.c -- 简单使用预处理 */
#include <stdio.h>
#define TWO 2
#define OW "Consistency is the last refuge of the unimaginative.\
- Oscar Wilde" /* 反斜杠将该定义延续到下一行 注意这里要对齐 */

#define FOUR TWO * TWO
#define PX printf("X is %d.\n", x)
#define FMT "X is %d.\n"

int main(void) {
    /* 宏展开 */
    int x = TWO;
    PX;
    x = FOUR; /* TWO * TWO 不是 4 */
    /* 宏展开到此为止 */
    printf(FMT, x);
    printf("%s\n", OW);
    printf("TWO: OW\n");
    return 0;
}
```
代码输出
```
X is 2.
X is 4.
Consistency is the last refuge of the unimaginative. - Oscar Wilde
TWO: OW
```
**预处理器不会进行实际的乘法运算，乘法运算是在编译期完成的**
**预处理也不会对表达式进行求值，也是在编译期完成，预处理只进行简单的替换**

宏定义可以嵌套其他宏（一些编译器不支持）  

那么何时使用字符串常量？
1. 绝大部分数字常量，应该用字符常量
2. 数字是 EOF 等系统代码

关于 const 关键字：
```c
#define LIMIT 20
const int LIM = 50;
static int data1[LIMIT]; // 有效
static int data2[LIM];   // 无效
const int LIM2 = LIMIT * 2 // 有效
const int LIM3 = LIM * 3 // 无效
```

在C语言中，非自动大小的数组，应该是整型常量表达式  

1. 类似 5 这样的整形
2. 枚举值
3. sizeof表达式返回值

这也是C和C++的区别，C++会把 cosnt 也当作常量表达式  

### 记号

从技术角度看，可以把宏的替换体看作是记号（token）型字符串，而不是字符型字符串，  
```c
#define FOUR 2*2
```
C预处理器记号，是宏替换体中单独的词，比如上述的 `2*2`  
但是下面的宏定义:
```c
#define FOUR 2 * 2
```
有3个记号。分别是 2、*、2  
当替换体中有多个空格时，记号型字符串和字符型字符串的处理方式不同
```c
#define EIGHT 4 * 8
```
如果预处理器把该替换体解释为字符型字符串，则把 4 * 8 替换EIGHT，即额外的空格是替换体的一部分  

如果预处理器把替换体解释为记号型字符串，则把 4 * 8 分为3个记号来替换EIGHT  

再实际应用中，一些C编译器会把替换体解释为字符型字符串

C编译器相比预处理器更加负责，由于编译器理解C语言规则  
因此不要求代码中的空格来分割记号，C编译器可以把2*2分割成3个记号，他能识别 2，也能识别运算符 *  

### 重定义常量

将已经定义好 #define SIZ = 2 * 2 修改 为 #define SIZ = 2*2 是不行的

因为 前一个替换体有3个记号，后一个替换体只有1个记号  

替换前要先 #undef （后边介绍）  

## 在#define中使用参数

直接上代码

```c
/* mac_arg.c -- 带参数的宏 */
#include <stdio.h>

#define SQUARE(x) x*x
#define PR(X) printf("The result is %d.\n", X)

int main(void) {
    int x = 5;
    int z;
    printf("x = %d\n", x);
    z = SQUARE(x);
    printf("Evaluating SQUARE(x): ");
    PR(z);
    z = SQUARE(2);
    printf("Evaluating SQUARE(2): ");
    PR(z);
    printf("Evaluating SQUARE(x+2): "); // 出问题了！
    PR(SQUARE(x+2));
    printf("Evaluating 100/SQUARE(2): "); // 出问题了！
    PR(100 / SQUARE(2));
    printf("x is %d\n", x);
    printf("Evaluating SQUARE(++x): "); // 出问题了！
    PR(SQUARE(++x));
    printf("After incrementing x is %x.\n", x);
    return 0;
}
```
代码输出
```
x = 5
Evaluating SQUARE(x): The result is 25.
Evaluating SQUARE(2): The result is 4.
Evaluating SQUARE(x+2): The result is 17.
Evaluating 100/SQUARE(2): The result is 100.
x is 5
Evaluating SQUARE(++x): The result is 42.
After incrementing x is 7.
```

可以看到 SQUARE(x+2) 的结果是17, 因为 `5+2*5+2=17`,

**预处理器不参与计算！只替换！！**

如果想让 `SQUARE(x+2)=49` 则需要给宏替换体增加括号 `(x) * (x)` 来规范运算优先级  

但是这样并没有解决所有问题  

`PR(100/SQUARE(2))` 的运算顺序是 `100 / (2) * (2)` 结果仍然等于 100，这不符合预期

如果想让 `100/SQUARE(2)=25` 则需要继续给宏替换体增加括号 `((x) * (x))`  

但是你以为这样就结束了吗？  

`SQUARE(++x)` 变成了 `((++x) * (++x))` 宏展开带入宏参数得 `6*7=42`  

有些编译器在计算乘法之前做了 `++` 运算，得到 36，有些则不然，比如我们的 gcc  

因此不要给任何函数传递 `++` 个人认为是一种好习惯  

### 用参数创建字符串 #运算符  

如果x是一个宏形参，那么#x就是转化字符串“x”的形参数名

上代码 

```c
/* sub_str.c -- 在字符串中替换 */
#include <stdio.h>
#define PSQR(x) printf("The square of "#x" is %d\n", ((x) * (x)))

int main(void) {
    int y = 5;
    PSQR(y);
    PSQR(2 + 4);
    return 0;
}
```
代码输出
```
The square of y is 25
The square of 2 + 4 is 36
```

`#x` 可以将数字替换为字母

### 预处理器粘合剂：##运算符

与#运算符类似，`##`运算符可用于类函数宏的替换部分，`##`还可用于对象宏的替换部分  

上代码

```c
/* glue.c -- 使用 ## 运算符 */
#include <stdio.h>
#define X_NAME(n) x ## n
#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n); // #n 完成字符串粘贴

int main(void) {
    int X_NAME(1) = 14; // 变成 int x1 = 14
    int X_NAME(2) = 20; // 变成 int x2 = 20
    int x3 = 30;        // x3 = 30

    PRINT_XN(1) // 变成 printf("x1=%d\n", x1)
    PRINT_XN(2)
    PRINT_XN(3)

    return 0;
}
```

代码输出

```
x1 = 14
x2 = 20
x3 = 30
```

这在逻辑运行前，预处理进行代码复用，预处理器NB

### 变参宏 ... 和 VA_ARGS

一些函数( printf() ) 接受数量可变的参数，`stdvar.h` 头文件中有需要的工具  

C99/C11 也提供类类似的工具，虽然C标准中未使用 “可变” 这个词  

通过把宏参数列表的参数写成 `...` 来完成可变传参的目标 

预定义宏 `__VA_ARGS__` 可用在替换部分中，表明省略号代表什么  

直接上代码 

```c
/* variadic.c -- 变参宏 */
#include <stdio.h>
#include <math.h>
#define PR(X, ...) printf("Message, "#X": "__VA_ARGS__)

int main(void) {
    double x = 48;
    double y;
    y = sqrt(x);
    PR(1, "x = %g\n", x);
    PR(2, "x = %.2g, y = %.4f\n", x, y);
    return 0;
}
```
代码输出
```
Message, 1: x = 48
Message, 2: x = 48, y = 6.9282
```

我个人不喜欢这样的写法

<br>  

## 宏和函数的选择

宏相比函数更加复杂，稍有不慎就会产生奇怪的错误  

**一些编译器规定宏只能定义成一行**

宏和函数是时间和空间的权衡，宏生成内联代码，即在程序中生成语句  

如果调用20次宏，既在程序中插入20行代码  

如果调用函数20次，程序中只有一份函数语句的副本，所以节省了空间 

然而另一方面，程序的执行必须进入程序内部，最后必须返回主调函数，这无形中增加了耗时  

宏的另一个有点是不用担心变量类型 `int` 或者 `float` 都能用 `SQUARE(x)` 宏

C99 提供了 3 种 可替换的方法 “内联函数”  

对于简单的函数，用宏可以更快的解决问题 

```c
#define MAX(x, y) ((x) > (y) ? (x) : (y))
#define ABS(x, y) ((x) < 0 ? (-x) : x)
#define ISSIGN(x) ((x) == '+' || (x) == '-' ? 1 : 0)
```

注意事项：
1. 宏名称中不能有空格，但是在替换字符串中可以有空格，ASIN C 允许在参数列表中有空格。 
2. 宏中用括号将宏参数扩起来，能够更正确的进行宏展开
3. 用大写字母表示宏函数更加通用，同时提醒程序猿这是tmd宏
4. 使用宏之前需要明确，和函数相比，宏是否会产生以外错误  

所以那几 us 值得用宏么  

<br>  

## 文件包含 #include 指令

预处理器在发现 #include 指令时，会把包内用引用到当前文件夹  

这相当于把被包含的文件内容，输入到原始文件中  

```c
#include <stdio.h>
#include "mystuff.h"
#include "/usr/biff/p.h"
```

**尖括号告诉预处理器在标准系统目录中查找文件**  
**双引号告诉预处理器现在当前目录查询，如果没有，再去标准目录**  

不同的编译器查找的方式也可能略有不同，不过不重要。  

头文件一般也会包含一部分预处理指令，以及函数的实现。 

包含一个大型的头文件不一定会显著的增加程序大小，再大部分情况下  
头文件内容是编译器生成最终代码时候需要的信息，而不是添加到最终代码中的材料  

<br>  


### 头文件示例

`names_st.h`:
```c
/* names_st.h -- names_st 头文件 */
#include <stdio.h>

// 常量声明
#define NAME_MAX_L 32

// 结构声明
struct names_st {
    char first[NAME_MAX_L];
    char last[NAME_MAX_L];
};

// 类型定义声明
typedef struct names_st names;

// 函数原型声明
void get_names(names *);
void show_names(const names *);
void * s_get(char * str, int n);
```
`names_st.c`:
```c
/* names_st.c -- 实现 names_st.h 头声明 */
#include <string.h>
#include "names_st.h"

// 函数定义
void get_names(names * pn) {
    printf("Input first: \n");
    s_get(pn->first, NAME_MAX_L);

    printf("Input last: \n");
    s_get(pn->last, NAME_MAX_L);
}

void show_names(const names * ptn) {
    printf("%s %s", ptn->first, ptn->last);
}

void * s_get(char * str, int n) {
    char * ret_val;
    char * find;
    ret_val = fgets(str, n, stdin);
    if (ret_val) {
        find = strchr(str, '\n');
        if (find) {
            *find = '\0'; // 将对应字段改为 结束符
        } else {
            while (getchar() != '\n')
                continue; // 处理缓冲区中的剩余字符
        }
    }
    return ret_val;
}
```
`main.c`:
```c
/* use_header.c -- 使用 names 结构 */
#include <stdio.h>
#include "names_st.h"

int main(void) {
    names candidate;
    get_names(&candidate);
    printf("welcome ");
    show_names(&candidate);
    printf(" to here\n");
    return 0;
}
```

编译时候需要同时编译 main.c 和 names_st.c 两个文件生成一个程序 

```shell
gcc -o prog -Wall main.c names_st.c
```

### 使用头文件

常见的头文件内容如下  

- 明示常量 ---- 例如 `stdio.h` 中 `EOF`, `NULL` 和 `BUFFERSIZE`（标准IO缓冲区大小）
- 宏函数 ---- 例如 `getc(stdin)` 通常用 `getchar()` 定义，而 `getc()` 通常用于定义较为复杂的宏
- 函数声明 ---- 例如 `string.h` 头文件（一些旧系统中是 strings.h）
- 结构模版定义 ---- 标准 IO 使用的 `FILE` 结构
- 类型定义 ---- `typedef`
- 外部声明 ---- `extern xxxx`
- 使用具有文件作用域、内部链接和 const限定符的变量后者数组

还可以使用头文件声明外部文件供其他文件共享 
```c
int status = 0;
```
在头文件中：
```c
extern int status; // 在头文件中，声明使用外部
```

<br>  

## 其他指令 

`#define` - 生成可及时使用的代码
`#undef` - 取消之前的 `#define` 定义的内容
`#line` - 重置行和文件信息  
`#if、#endif、#ifdef、#else、#ifndef、#else、#elif` 分情况编写代码
`#error` - 给出错误信息  
`#pragrm` - 向编译器发出指令  

### undef 指令 

```c
#define LIMIT 400
/* ... 做一些别的事情 */
#undef LIMIT // 取消 LIMIT定义

#define LIMIT 300 // 重新定义
```
如果想用一个名称，但是又不确定是否用过，可以先 `#undef` 在 `#define`

笑死。可能是我见的世面少吧，程序员不知道自己定义了啥？？
一套稳定的系统，谁敢轻易改定义？？

### 从 C 预处理器角度看待问题

预处理器发现预处理指令标识符时  

会把该标识符当作 **已定义** 或 **未定义** 的  

这里的**已定义**表示由预处理器定义  

如果标识符是由同一个文件中前面的 `#define` 创建的宏名，而且没有 `#undef` 指令关闭 那么该标识符是已定义的  

如果标识符不是宏，而是一个 文件作用域的C变量，那这个变量对于预处理器来说就是为定义的

```c
#define LIMIT 1000 // LIMIT 是已定义的
#define GOOD       // GOOD 是已定义的
#define A(X) ((-(X)) * (X)) // A(X) 是已定义的
int q;             // q 是未定义的
#undef GOOD        // GODD 取消定义，是未定义的 
```

`#define` 的作用域从它在文件中的声明处开始 直到用 `#undef` 取消为止
或延伸至文件结尾  
如果宏通过 `#include` 引入，那么 `#define` 在文件中的位置取决于 `#include` 的位置  

还有一些特殊的宏 比如  `__FILE__` `__DATE__` 这些一定已经定义，且不能取消定义

### 条件编译

可以使用其他指令创建条件编译 (**conditinal compilation**) 告诉编译器根据条件进行编译  

#### #ifdef、#else 和 #endif 指令  

使用较新的编译器 和 ANSI C 标准 可以这样写：
```c
#ifdef MAVIS // 如果已经用 #define 定义了 MAVIS
    #include "horse.h" // 引入 horse.h
    #define STABLES 5
#else        // 否则，引入 cow.h
    #include "cow.h"
    #define STABLES 15 
#endif
```
如果是比较旧的编译器：
```c
#ifdef MAVIS // 如果已经用 #define 定义了 MAVIS
#include "horse.h" // 引入 horse.h
#define STABLES 5
#else        // 否则，引入 cow.h
#include "cow.h"
#define STABLES 15 
#endif       // 必须存在
```

旧编译器要求预处理指令左对齐  

预处理器不识别用于标记块儿的话括号  

上代码 

```c
/* if_def.c -- 条件编译 */
#include <stdio.h>

#define LIMIT 4
#define JUST_CHECKING

int main(void) {
    int i;
    int total = 0;
    for (i=1; i<=LIMIT; i++) {
        total += 2 * i * i;
#ifdef JUST_CHECKING
        printf("i=%d total=%d\n", i, total);
#endif
    }
    puts("done");
    return 0;
}
```
代码输出
```
i=1 total=2
i=2 total=10
i=3 total=28
i=4 total=60
done
```
如果取消 `JUST_CHECKING`

```c
/* if_def.c -- 条件编译 */
#include <stdio.h>

#define LIMIT 4
#define JUST_CHECKING

int main(void) {
    int i;
    int total = 0;
#undef JUST_CHECKING
    for (i=1; i<=LIMIT; i++) {
        total += 2 * i * i;
#ifdef JUST_CHECKING
        printf("i=%d total=%d\n", i, total);
#endif
    }
    puts("done");
    return 0;
}
```
代码输出
```
done
```
可以通过这样的方法来调试代码，`debug` 阶段打开 `JUST_CHECKING` `release` 去掉它  

#### #ifndef 指令  

`#ifndef` 指令与 `#ifdef` 指令的使用方式类似，但是它们的意义完全相反  

`#ifndef` 代表如果宏没有被定义过 ，比如

```c
/* arrays.h */
#ifndef SIZE
    #define SIZE 99
#endif
```
（旧的实现可能不允许使用缩进的`#define`）  

通常包含多个头文件时，其中的文件可能包含了相同的宏定义    

`#ifndef` __可以防止相同的宏被重复定义__   
  
这个感觉还挺有用的  

`#ifndef` 还有另一个用法  

比如把下面的代码写入头文件
```c
#include "arrays.h"
```
SIZE 被设定为 100，但是如果把下面的代码写入头文件
```c
#define SIZE = 10
#include "arrays.h"
```
SIZE 被设置为 10，因为 arrays.h 里有 ifndef 来做前置判定。

通过这样的方法，可以先用较小的测试集进行功能测试，编译线上代码之前再放开  

这样就不用懂 arrays.h 本身了  

`#ifndef` 也常用用防止多次包含同一个头文件，应该向下面这样设置头:  

```c
/* things.h */
#ifndef THINGS_H_
    #define THINGS_H_
    /* 省略了头文件中的其他内容 */
#endif
```
假设该文件被包含多次，当预处理器发现该文件被包含时，`THINGS_H_` 是未被定义的  
所以定义了 `THINGS_H_`, 并接着处理该文件的其他部分。  

当预处理器发现第2次 `things.h` 被 `include` 时 就会跳过头文件内容的初始化 

为什么要多次包含同一个文件？？  

因为多个头文件中有可能包含着其他的同一个头文件，这样做有什么问题？  

一些文件有某些项（如一些结构类型的声明）只能在一个文件中出现一次。  

C标准头文件使用 `#ifndef` 技巧避免重复包含 但是这样做有个问题  
如果确保测试使用的标识符没有在别处被定义？？  

用文件名作为标识符，用下划线代替文件名中的点字符，用下划线做前后缀  

但是由于标准库用了`_`前缀，比如 `stdio.h`:

```c
#ifndef _STDIO_H
    #define _STDIO_H
#endif
```
因此，**自己写的头文件应该避免用前置下划线，从而避免与标准库头文件冲突**。  

上代码 完善之前的 `names_st.h` 头文件

```c
/* names_st.h -- names_st 头文件 */
#ifndef NAMES_ST_H
    // 常量声明
    #define NAME_MAX_L 32

    // 结构声明
    struct names_st {
        char first[NAME_MAX_L];
        char last[NAME_MAX_L];
    };

    // 类型定义声明
    typedef struct names_st names;

    // 函数原型声明
    void get_names(names *);
    void show_names(const names *);
    void * s_get(char * str, int n);
#endif
```

看 加入条件编译后，能放心一些  

#### #if 和 #elif 很像  

```c
#if SYS == 1
    #include "ibm.h"
#endif
```
早期的编译器实现不支持 #elif
```c
#if SYS == 1
    #include "ibmpc.h"
#elif SYS == 2
    #include "vax.h"
#elif SYS == 3
    #include "mac.h"
#endif
```
较新的编译器使用 `#if defined(XXX)` 比较好
```c
#if defined(IBMPC)
    #include "ibmpc.h"
#elif defined(VAX)
    #include "vax.h"
#elif defined(MAC)
    #include "mac.h"
#endif
```
如果在vax虚拟机上运行代码 那么应该提前加入下面定义：
```c
#define VAX
```


### 预定义宏

C标准定义了一些与定义宏  

|宏|含义|
|-|-|
|`__DATE__`|预处理的日期("Mmm dd yyyy") 形式的字符串字面量|
|`__FILE__`|当前原代码文件名的字符串字面量|
|`__LINE__`|当前元代码文件中行好的整形常量|
|`__STDC__`|设置为1时，表明遵守C标准|
|`__STDC_HOSTED__`|本季环境设置为1；否则设置为0|
|`__STDC_VERSION__`|支持C99标准，设置`199901L`; 支持C11标准，设置 `201112L`
|`__TIME__`|翻译代码的时间, 格式为 "hh:mm:ss"|

C99 标准提供了`__func__` 预处理标识符，它展开为一个代表函数名的字符串（该函数包含标识符）  

`__func__` 必须拥有函数作用域 而从本质上看它具有文件作用域  

因此 `__func__` 是C语言的预定义标识符，而不是预定义宏  

上代码 

```c
/* pre_def.c -- 预定义宏和预定义标识符 */
#include <stdio.h>

void why_me();

int main(void) {
    printf("The file is %s. \n", __FILE__);
    printf("The date is %s. \n", __DATE__);
    printf("The time is %s. \n", __TIME__);
    printf("The version is %ld. \n", __STDC_VERSION__);
    printf("The line is %d. \n", __LINE__);
    printf("The func is %s. \n", __func__ );
    why_me();
    return 0;
}

void why_me() {
    printf("The line is %d. \n", __LINE__);
    printf("The func is %s. \n", __func__ );
}
```
代码输出
```
The file is main.c. 
The date is Jun 17 2024. 
The time is 12:40:10. 
The version is 201112. 
The line is 11. 
The func is main. 
The line is 18. 
The func is why_me.
```
没啥可说的，在其他编程语言中也看到过，继承了C语言之大统  

### #line 和 #error

`#line` 指令重置 `__LINE__` 和 `__FILE__` 宏报告中的行号和文件名   

```c
#line 1000        // 把当前行号重置为 1000
#line 10 "cool.c" // 把行号重置为 10，把文件名重置为 cool.c 
```
感觉用途不广泛 

`#error` 指令让预处理器发出一条错误，编译过程应该中断  

```c
#if __STDC_VERSION__ != 201112L
#error Not C11
#endif
```
这样可以触发编译失败  

### #pragma

在现代软件工程中，可以通过命令行参数 或者 IDE 菜单修改编译器的一些设置  
比如 在《clion》编辑器中，可以配置C标准是99还是11或者其他  

`#pragma` 把编译器指令放入原代码中，例如在开发`C99`时，标准被称为 `C9X`  
可以通过下面的指令，告诉编译器支持 C99:
```c
#pragma c9x on
``` 
C99 提供了3个标准编译器指示，但是超出了本教程的讨论范围  

不在此处过多介绍，多学多看多实操来完善吧  

### 范型选择(C11)

**范型编程（gereric programming）** 是指那些没有特定类型，但是一旦确定类型，就可以转化成特定类型的代码。  

C++ 可以在模版中创建范型算法，C11之前不支持，但是C11标准出来后，新增了一种表达式  
**范型选择器（generic selection expression）**  

可以根据表达式类型，选择一个值，范型表达式不是预处理器指令，在一些范型编程中 
它常用作 `#define` 的一部分  

```c
_Generic(x, int 0, float: 1, double: 2, default: 3)
```
第一个选项是表达式，后面由一个类型: 值 组成  

把宏定义和范型选择器组合：

```c
#define MYTYPE(X) _Generic((X), \
int: "int", float: "float", double: "double", default: "other")
```
j8 说一堆看不懂，上代码  

```c
/* my_type.c -- 预定义宏和预定义标识符 */
#include <stdio.h>

#define MY_TYPE(X) _Generic((X), int: "int", float: "float", double: "double", default: "other")

int main(void) {
    int d = 5;

    printf("%s\n", MY_TYPE(d));       // X 是 int 类型
    printf("%s\n", MY_TYPE(2.0 * d)); // X 是 float 类型
    printf("%s\n", MY_TYPE(3L));      // X 是 long 类型
    printf("%s\n", MY_TYPE(&d));      // X 是 * int 类型

    return 0;
}
```
代码输出:
```
int
double
other
other
```
有点懂了

此示例只是演示了 _Generic 的基本能力，后续实际操作中可以对 #define 进行扩展  

对于范型选择器，程序不会第一时间求值，而是先确定类型, 再执行后续操作    

也就是说想用 _Generic 只能 #define 宏编程，哈哈。    

<br>  

## 内联函数  






