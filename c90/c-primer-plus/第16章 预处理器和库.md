# C预处理器和C库

> 预处理指令：#define #include #ifdef #else #endif #ifndef #if #elif #line #error #program  
> 关键字：_Generic, _Noreturn, _Static_assert  
> 函数/宏 sqrt(), atan(), atan2()、exit()、atexit()、assert()、memcpy()、memmove() ...  
> C预处理器的其他功能  
> 通用选择表达式  
> 内联函数  
> C库概述和一些特殊方法  

C 标准不仅描述C语言，也描述预处理器、C标准库有哪些函数、以及这些函数的工作原理  

<br>

# 翻译的第一步

1) 预处理之前，编译器必须对程序进行一些翻译处理，首先编译器会把代码中出现的一些字符，映射到原始字符集  
该过程处理 **多字节字符** 和 **三字符序列** 字符扩展让C更加国际化  

2) 然后，编译器定位每个 \ 后面跟着换行符的实例，并删除它们，比如把下面两个物理行删减位一个逻辑行  
    ```c
    printf("hello \
    world.")
    ```   
    一个逻辑行可以是多个物理行  
  
3) 之后，编译器把文本划分成**预处理记号序列**、**空白序列**和**注释序列**  
 记号是由空格、制表符和换行符分割的项，详见16.2.1
 比如
    ```c
    int /*这里将会被分割*/ fox;
    // 将变成
    int fox;
    ```

4) 程序已经做好预处理准备，预处理器开始查找一行中以`#`开头的预处理指令  

<br>

## 明示常量  #define

每行 #define 由 3部分组成 

1) `#define` 指令本身
2) 选定的缩写，也称为 ‘宏’，不允许有空格，必须遵循C语言命名标准
3) 替换列表或替换体，预处理器一点找到改宏名，将用替换体代替该宏

宏替换的过程被称为**宏展开（macro expansion）**

宏可以是特定的值，或者是表达式  

```c
/* pre_proc.c -- 简单使用预处理 */
#include <stdio.h>
#define TWO 2
#define OW "Consistency is the last refuge of the unimaginative.\
- Oscar Wilde" /* 反斜杠将该定义延续到下一行 注意这里要对齐 */

#define FOUR TWO * TWO
#define PX printf("X is %d.\n", x)
#define FMT "X is %d.\n"

int main(void) {
    /* 宏展开 */
    int x = TWO;
    PX;
    x = FOUR; /* TWO * TWO 不是 4 */
    /* 宏展开到此为止 */
    printf(FMT, x);
    printf("%s\n", OW);
    printf("TWO: OW\n");
    return 0;
}
```
代码输出
```
X is 2.
X is 4.
Consistency is the last refuge of the unimaginative. - Oscar Wilde
TWO: OW
```
**预处理器不会进行实际的乘法运算，乘法运算是在编译期完成的**
**预处理也不会对表达式进行求值，也是在编译期完成，预处理只进行简单的替换**

宏定义可以嵌套其他宏（一些编译器不支持）  

那么何时使用字符串常量？
1. 绝大部分数字常量，应该用字符常量
2. 数字是 EOF 等系统代码

关于 const 关键字：
```c
#define LIMIT 20
const int LIM = 50;
static int data1[LIMIT]; // 有效
static int data2[LIM];   // 无效
const int LIM2 = LIMIT * 2 // 有效
const int LIM3 = LIM * 3 // 无效
```

在C语言中，非自动大小的数组，应该是整型常量表达式  

1. 类似 5 这样的整形
2. 枚举值
3. sizeof表达式返回值

这也是C和C++的区别，C++会把 cosnt 也当作常量表达式  

### 记号

从技术角度看，可以把宏的替换体看作是记号（token）型字符串，而不是字符型字符串，  
```c
#define FOUR 2*2
```
C预处理器记号，是宏替换体中单独的词，比如上述的 `2*2`  
但是下面的宏定义:
```c
#define FOUR 2 * 2
```
有3个记号。分别是 2、*、2  
当替换体中有多个空格时，记号型字符串和字符型字符串的处理方式不同
```c
#define EIGHT 4 * 8
```
如果预处理器把该替换体解释为字符型字符串，则把 4 * 8 替换EIGHT，即额外的空格是替换体的一部分  

如果预处理器把替换体解释为记号型字符串，则把 4 * 8 分为3个记号来替换EIGHT  

再实际应用中，一些C编译器会把替换体解释为字符型字符串

C编译器相比预处理器更加负责，由于编译器理解C语言规则  
因此不要求代码中的空格来分割记号，C编译器可以把2*2分割成3个记号，他能识别 2，也能识别运算符 *  

### 重定义常量

将已经定义好 #define SIZ = 2 * 2 修改 为 #define SIZ = 2*2 是不行的

因为 前一个替换体有3个记号，后一个替换体只有1个记号  

替换前要先 #undef （后边介绍）  

## 在#define中使用参数

直接上代码

```c
/* mac_arg.c -- 带参数的宏 */
#include <stdio.h>

#define SQUARE(x) x*x
#define PR(X) printf("The result is %d.\n", X)

int main(void) {
    int x = 5;
    int z;
    printf("x = %d\n", x);
    z = SQUARE(x);
    printf("Evaluating SQUARE(x): ");
    PR(z);
    z = SQUARE(2);
    printf("Evaluating SQUARE(2): ");
    PR(z);
    printf("Evaluating SQUARE(x+2): "); // 出问题了！
    PR(SQUARE(x+2));
    printf("Evaluating 100/SQUARE(2): "); // 出问题了！
    PR(100 / SQUARE(2));
    printf("x is %d\n", x);
    printf("Evaluating SQUARE(++x): "); // 出问题了！
    PR(SQUARE(++x));
    printf("After incrementing x is %x.\n", x);
    return 0;
}
```
代码输出
```
x = 5
Evaluating SQUARE(x): The result is 25.
Evaluating SQUARE(2): The result is 4.
Evaluating SQUARE(x+2): The result is 17.
Evaluating 100/SQUARE(2): The result is 100.
x is 5
Evaluating SQUARE(++x): The result is 42.
After incrementing x is 7.
```

可以看到 SQUARE(x+2) 的结果是17, 因为 `5+2*5+2=17`,

**预处理器不参与计算！只替换！！**

如果想让 `SQUARE(x+2)=49` 则需要给宏替换体增加括号 `(x) * (x)` 来规范运算优先级  

但是这样并没有解决所有问题  

`PR(100/SQUARE(2))` 的运算顺序是 `100 / (2) * (2)` 结果仍然等于 100，这不符合预期

如果想让 `100/SQUARE(2)=25` 则需要继续给宏替换体增加括号 `((x) * (x))`  

但是你以为这样就结束了吗？  

`SQUARE(++x)` 变成了 `((++x) * (++x))` 宏展开带入宏参数得 `6*7=42`  

有些编译器在计算乘法之前做了 `++` 运算，得到 36，有些则不然，比如我们的 gcc  

因此不要给任何函数传递 `++` 个人认为是一种好习惯  

### 用参数创建字符串 #运算符  

