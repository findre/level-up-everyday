> gets() gets_s() fgets() puts() fputs()   
> stract() strncat() strcmp() strncmp()  
> strcpy() strncpy() strintf() strnintf()
>  
> 创建并使用字符串
> 使用命令行参数

学完数组学字符串。  
常见流程了。  

## 表示字符串和字符串IO

字符串的本质是以\0结尾的字符数组。  
字符串很常用，所以C语言提供了很多函数用来处理字符串。  

上代码
```c
/* strings1.c */
#include <stdio.h>
#define MSG "I am a string content "
#define MAXLENGTH 81

int main(void) {
    char words[MAXLENGTH] = "I am a string in array."; // char array 定义法
    const char * ptr1 = words;

    puts("Here are some strings: ");
    puts(MSG);
    puts(words);
    puts(ptr1);
    words[8] = 'p';
    puts(words);
    
    return 0;
}
```
代码输出
```
Here are some strings: 
I am a string content 
I am a string in array.
I am a string in array.
I am a spring in array.
```
`puts()` 函数只接受字符串，且会自动向末尾增加 '\n' 换行符。

### 在程序中定义字符串

#### 字符串字面量
用双引号印起来的数据称为**字符串字面量**。  
`char username[50] = "Hello"" World" " zzz !"` 等价于  
`char username[50] = "Hello World zzz !"`  
在 ANSI C 中，`""""` `"" ""` 会被自动合并为一段字符串。  
双引号需要用 `\"` 来编写。  
字符串常量属于静态存储类别(**static storage class**)。

上代码
```c
/* str_ptr.c -- 字符串看作指针 */
#include <stdio.h>

int main(void) {
    printf("%s, %p, %c\n", "We", "are", *"super world");
    return 0;
}
```
代码输出
```
We, 0x10b6befa1, s
```
明显就是字符数组，一摸一样。  

#### 字符串的声明
`const char username[15] = "Johnny Leaf";`   
`const char username[15] = {'J', 'o', ...., 'L', 'e', 'a', 'f', '\0'};`  
这个 '\0' 很重要，没有的话就不能称为“字符串”  
明显是第一种更佳。

#### 数组和指针
`const char * pt1 = "Hello World My Bro";`  
`const char ar1[] = "Something is pointer at me"; `
1. `ar1[]` 在计算机内存中被分配为内涵29个元素的数组（28个 char 以及一个'\n'）  
2. 每个元素被初始化为字符串字面量对应的字符。 
3. 通常字符串都作为可执行文件的一部分存储在数据段中。 
4. 把程序载入内存时，也载入了字符串。
5. 字符串通常位于静态存储区(static memory)中。程序运行开始后才会为该数组分配内存。
6. 此时才会将数组拷贝到内存中去。**此时字符串有2个副本，一个是静态存储区中的字面量，一个是存储在ar1中的数组**。
7. 此后，编译器便把 `ar1` 识别为 `&ar1[0]` 首个元素地址的别名。
8. `ar1` 是地址常量，不能修改。如果改了ar1，则修改了地址的存储位置。
9. 可以进行 `ar1 + 1` 但是不能进行 `ar1++` 操作。
10. 指针形式 `*pt1` 同理，但是它是独立的，有自己的地址，所以pt1++ 是允许的 它指向下一个字符  

上代码

```c
/* address.c -- 字符串的地址 */
#include <stdio.h>
#define MSG "I'm special"

int main(void) {
    char ar[] = MSG;      // 拷贝
    char ar1[] = MSG;     // 拷贝
    const char *pt = MSG; // 直接指向

    printf("address \"I'm special\": %p\n", "I'm special");
    printf("address            ar: %p\n", ar);
    printf("address           ar1: %p\n", ar1);
    printf("address           *pt: %p\n", pt);
    printf("address           MSG: %p\n", MSG);
    printf("address \"I'm special\": %p\n", "I'm special");

    return 0;
}
```
代码输出
```
address "I'm special": 0x106da0f18
address            ar: 0x7ff7b91622cc
address           ar1: 0x7ff7b91622c0
address           *pt: 0x106da0f18
address           MSG: 0x106da0f18
address "I'm special": 0x106da0f18
```

1. `MSG` 与 字符串 "I'm special" 的存储位置相同，不管出现多少次。编译器可以把相同的字符串字面量存储在同一个地址。  
2. 不同的编译器处理方式不同，也有可能 "I'm special" 会存储在多个地址。  
3. 静态数据 MSG、"I'm special" 使用的静态内存与 ar、ar1 使用的动态内存不同。特定的编译器使用不同的长度表示两种内存类型。
4. 用数组还是指针去表示字符串没有那么重要，看怎么使用。

#### 数组和指针的区别

`char heart[] = "I Love Tillie!";`    
`const char *head = "I Love Tillie!";`

1. 数组名 heart 是常量。  
2. 指针名 head 是变量。  

heart 和 head 都可以用数组表示法来取值

```c
for (i = 0; i < length; i++) {
    printf("%c %c", heart[i], head[i]);
}
```

heart 和 head 都可以使用加法操作。

```c
for (i = 0; i < length; i++) {
    printf("%c %c", *(heart+i), *(head+i));
    break;
}
```

但是只有 指针 head 可以进行累加操作。

```c
while (*head != '\n') {
    putchar(*(head++));
}
```

想让 heart 和 head 统一。

```c
head = heart // 现在 head 指向 &heart[0]
```

但是不可以这样做

```c
heart = head // 非法构造 不能这样写
```

赋值运算符的左侧必须是变量，不能是常量。  

未使用 const 限定符指针的情况如下 这样做是否允许呢？

```c
char * word = "frame";
word[1] = '1';
```
编译器可能允许这样做。但是！！这样不符合C标准，而且也不安全。  
这样做可能导致内存访问错误。  
前面提到过，编译器可能会针对相同的字面量的多个字符串用同一个内存副本。  
比如下方代码所示
```c
char * p1 = "Kligon";  
p1[0] = 'F'; // is ok?
printf("Kligon");  
printf(": Beware the %ss\n", "Kligon");  
```
编译器可以用相同的地址替换每一个 "Kligon"。  
如果用指针修改了 "Kligon" 的某个字符，可能会影响所有使用此字符串的部分，让整个程序发生错误。    

推荐用法：`const char * pti = "Kligon";`  

```c
/* arr_char.c -- 指针数组，字符串数组 */
#include <stdio.h>
#define S_LEN 40
#define LIM 5

int main(void) {
    const char *my_talents[LIM] = {
            "Adding numbers swiftly",
            "Multiplying accurately",
            "Stashing date",
            "Following instructing to the letters",
            "Understand the C lang"
    };

    char your_latents[LIM][S_LEN] = {
            "Walking in a straight line",
            "Sleeping",
            "Watching television",
            "Mailing letters",
            "Reading Email"
    };

    int i;

    puts("Let's compare latents.");
    printf("%-36s %-25s\n", "My Talents", "Your Talents");
    for (i = 0; i < LIM; i++) {
        printf("%-36s %-25s\n", my_talents[i], your_latents[i]);
    }
    printf("\nsize of my_talents is %zd, your_talents size is %zd\n", sizeof(my_talents), sizeof(your_latents));
    return 0;
}
```
代码输出
```
Let's compare latents.
My Talents                           Your Talents             
Adding numbers swiftly               Walking in a straight line
Multiplying accurately               Sleeping                 
Stashing date                        Watching television      
Following instructing to the letters Mailing letters          
Understand the C lang                Reading Email            

size of my_talents is 40, your_talents size is 200
```
从某些方面看 my_telents 和 your_telents 相似，取字符逻辑都一样。   
但是他们在内存中的存储方式是不一样的。 

my_telents   是一个内含 5个指针的数组 （推荐）。  
your_telents 是一个内含 5个数组的数组。  

my_telents   指针指向初始化时，所用的字符串的字面量，存储在静态内存区域中 （推荐）。  
your_telents 存储着每一个静态字面量的副本，所以每个字符串都被存储了2次。  

因此推荐使用指针来指向字符串。它的空间利用率更好。  

但是它也有缺点。  

指针指向静态内存不能修改。如果想随时修改，还是得用 your_telents 那样的拷贝副本。、

