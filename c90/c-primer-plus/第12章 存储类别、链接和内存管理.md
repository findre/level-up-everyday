# 存储类别、链接以及内存分配
> 关键字: auto、extern、static、register、cosnt 。。。  
> 函数rand()、time()、malloc() 。。。  
> 如何确定变量的作用域和声明周期  
> 设计更复杂的程序  
>

<br>  

## 存储类别
```c
int entity = 3;
```
1. 被存储的每一个值都占有一定的物理内存
2. C语言把这样的一块儿内存称为对象(object)
3. 对象可以存储一个或多个值
4. 对象根据实际值具有适当大小
5. entity 在C语言中称为标识符(identifier), 用来指定特定对象内容。

```c
const char * pc = "Behold a string literal"
```
### 作用域
1. 块儿作用域
2. 函数作用域，仅用于 goto 语句的标签。范围延伸至整个函数
3. 函数原型作用域，用于函数原型中的形参名。
4. 文件作用域，用于变量的定义位于函数外部。

> .c 扩展中一般包含一个或多个 .h 头文件  
> .h 又可能包含多个其他 .h 文件  
> c 预处理程序实际使用文件内容替换掉 #include 内容  
> 因此编译器源代码文件和所有的头文件实际是一个包含信息的单独文件  
> 这个文件被称为 翻译单元  
> 描述一个具有文件作用域的变量时，它的范围可能延伸到整个翻译单元  
> 一个由多个源代码组成的文件，包含多个翻译单元  

### 链接
1. 外部链接 变量可以在多个文件程序中使用
2. 内部链接 变量只能在一个翻译单元中使用
3. 无链接 指所有函数，函数原型以及块儿声明的变量

### 存储期
1. 静态存储期 
   1. 针对文件作用域的变量`static`只声明链接属性，而非存储期。
   2. static 声明的变量具有内部链接
2. 线程存储期 
   1. 整个线程周期内一直存在。
   2. 以 _Thread_local 声明的对象，每个线程获得其私有备份
3. 自动存储期
   1. 块儿作用域变量通常具有自动存储期
   2. 在块儿退出时释放
   3. 变长数组是从声明处开始到块儿末尾结束
4. 动态分配存储期

```c
void more(int number) {
    int index;
    static int ct = 0 // 函数内部的静态变量
}
```
函数内部的静态变量，存在于整个程序的声明周期，但是仅仅在函数内部能使用

### 自动变量
属于自动存储类别的标识具有自动存储期、块儿作用域且无链接。  
默认情况下，声明在函数或块儿或函数头中的任何变量都属于自动变量。  
可以使用 auto 来声明表示符具有自动存储期，但是完全没必要。
```c
int main(void) {
    auto int index = 1; // 完全没有必要
    return 0;
}
```
主要 C++ 也有 auto 语句，但是他们的功能完全不一样。  

### 寄存器变量
如果不刻意为之，大多数情况下，变量通常存储在内存中。  
如果幸运的话，寄存器变量存储在CPU寄存器中。  
寄存器变量无法访问地址。  
使用存储类别说明符，可以“请求”CPU存储对象到寄存器变量。  
```c
int main(void) {
    register int number = 0; // register 声明
    return 0;
}
```
并非使用了 register 就一定会存储在 CPU寄存器上。  
也不是所有数据都可以存储在寄存器（double）  
编译器必须根据寄存器或最快内存数量来衡量你的请求。
函数声明也可以使用 register 来标识变量是一个寄存器变量 `void exp(register int)`

### 块儿作用域的静态变量
1. `静态变量`听起来很矛盾。这里的静态并非不变的意思。 
2. `静态`指的是变量在内存中原地不动。并不是说他的值不变。
3. 具有文件作用域的变量，自动具有静态存储周期。延伸到整个程序结束。
4. 这种变量具有块儿作用域，无链接，具有静态存储周期。  

上代码
```c
/* loc_stat.c -- 使用局部静态变量 */
#include <stdio.h>

void try_stat(void);

int main() {
    int count;
    for (count = 1; count <= 3; count++) {
        printf("loop %d times, ", count);
        try_stat();
    }
    return 0;
}

void try_stat(void) {
    int fade = 1;
    static int stat = 1;
    printf("fade is %d, stat is %d\n", fade++, stat++);
}
```
代码输出
```
loop 1 times, fade is 1, stat is 1
loop 2 times, fade is 1, stat is 2
loop 3 times, fade is 1, stat is 3
```
可以看到 stat 不再执行初始化语句。  
stat 在编译阶段会被初始化1次，以后就不会再初始化了。

### 外部链接的静态变量

1. 外部链接的静态变量具有文件作用域、外部链接和静态存储周期
2. 该类型有时候被称为外部存储类型(external static class)
3. 为了声明使用了外部变量，可以使用 `external` 关键字来强调声明
```c
int Errupt;       // 定义外部变量
double Up[100];   // 外部定义的数组
extern char Coal; // 如果Coal被定义在另外一个文件

void next(void);
int main(void) {
    extern int Errupt;  // 可选的声明 完全可以省略
    extern double Up;   // 可选的声明 完全可以省略
    return 0;
}
```
4. 外部变量只能定义一次
```c
/* one.c */
char permis = 'N';

/* two.c */
extern char permis = 'W' // 错误！permis 已经定义过了
```

main 中的 2条声明完全可以省略。仅仅提示使用的是外部变量。  
如果不加 extern 则编译器还是会在main内部重新定义独立的局部变量。  
上代码
```c
/* global.c -- 使用外部变量 */
#include <stdio.h>

int units = 0;  // 初始化外部变量

void critic(void);

int main() {
    extern int units; // 可选的重复声明
    puts(">>> start");
    if (scanf("%d", &units) == 1) {
        while (units != 56) {
            critic();
        }
    }
    puts(">>> stop");
    return 0;
}

void critic(void) {
    puts(">>> In critic, wait input again");
    int ret = scanf("%d", &units);
    if (ret != EOF && ret == 1) {
        puts(">>> critic input down");
    }
}
```
代码输出
```
>>> start
5 
>>> In critic, wait input again
23
>>> critic input down
>>> In critic, wait input again
56
>>> critic input down
>>> stop
```
没什么可说的


### 内部链接的静态变量
1. 该文件具有 静态存储周期、文件作用域和内部链接。
2. 用 static 声明变量
3. `static int number = 0;` 这些变量过去被称为外部静态变量，但是有点自相矛盾。
4. 暂时没有新的简称，所以称为内部链接的静态变量。
5. 内部静态变量只能用于同一个文件中的函数。

```c
int traveler = 1;        // 外部变量，里外都能用，文件作用域
static int stayhome = 1; // 内部静态，只能同一个文件使用， 文件作用域
int main() {
    extern int traveler; // 使用定义在别处的 traveler
    extern int stayhome; // 使用定义在别处的 stayhome
}
```

6. 只有 traveler 可用于其他翻译单元


### 多文件
1. 程序由多个翻译单元共同组成。
2. 复杂的C程序通常由多个源代码组合而成，有些情况下多个源代码需要使用同一个变量。
3. C通过1个文件对其进行声明，其他文件使用 extern 声明进行变量共享。
4. 除了一个定义式声明以外，其他文件都需要使用 extern 来进行获取变量。

### 存储类别说明符
1. auto 表明变量具有自动存储周期，只能用于块儿。块儿变量本身就有自动存储周期
2. register 也只能用于块儿作用域的变量，它把变量归类为寄存器存储类别，以最快方式读写，并保证变量地址不被获取。
3. static 具有静态存储周期，文件作用域受限于该文件。
4. extern 声明对象来自外部链接

上代码，温故而知新
```c
/* mian.c */
#include <stdio.h>

void report_count(void);
void accumulate(int k);

int count = 0; // 外部链接

int main() {
    int value;       // 自动变量 auto
    register int i;  // 寄存器变量, 读写速度快，无法获取地址。
    printf("Enter a positive int (0 2 quit)\n");
    while (scanf("%d", &value) == 1 && value > 0) {
        ++count;     // 使用文件作用域产生的变量
        for (i = value; i >= 0; i--) {
            accumulate(i);
        }
        printf("Enter a positive int (0 2 quit)\n");
    }
    report_count();
    return 0;
}

void report_count() {
    printf("Loop executed %d times\n", count);
}
```
```c
/* partb.c */
#include <stdio.h>

extern int count;       // 引入式声明，外部链接

static int total = 0;   // 静态对象，内部链接

void accumulate(int k);

void accumulate(int k) {     // k 具有块儿作用域，无链接
    static int subtotal = 0; // 静态，无链接
    if (k <= 0) {
        printf("loop cycle: %d\n", count);
        printf("subtotal: %d, total: %d\n", subtotal, total);
        subtotal = 0;
    } else {
        subtotal += k;
        total += k;
    }
}
```
代码输出
```
Enter a positive int (0 2 quit)
10
loop cycle: 1
subtotal: 55, total: 55
Enter a positive int (0 2 quit)
5
loop cycle: 2
subtotal: 15, total: 70
Enter a positive int (0 2 quit)
1
loop cycle: 3
subtotal: 1, total: 71
Enter a positive int (0 2 quit)
0
Loop executed 3 times
```
没啥可说的，看代码。

### 存储类别和函数
1. 函数也有存储类别，可以是外部（默认）或者 静态函数
2. C99 新增了内联函数。
3. 定义以及声明等，与上方类似。

```c
double gamma(double)        // 默认为外部函数
static double gama2(double) // 静态内部，文件范围内私有。
extern double gama3(double) // 引入式声明，函数是外部链接。 
```

### 存储类别的选择
1. 绝大部分是 “自动存储类别”。嘻嘻，没什么可说的。
2. 随意使用外部变量的后果的成本一定大于它带来的便利，这是人性决定的。
> “按需知道” 原则，是永恒的黄金法则  
> 尽量在函数内部解决函数任务  
> 只共享那些必须共享的东西，最好是 const  

<br>  

## 随机函数和静态变量

这里要用到C标准提供的 rand() 函数

先自己写一个
```c
//
// Created by JohnnyLeaf on 2024/4/18.
//
static unsigned long int next = 1; // 随机种子

unsigned int rand0(void) {
    /* 生成随机数魔术公式 */
    next = next * 1103511245 + 12345;
    return (unsigned int) (next / 65536) % 32768;
}
```

