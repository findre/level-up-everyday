# 文件的输入输出
>  
>  fopen()、getc()、putc()、exit() ...  
>  
>  如何使用C标准的文件输入以及输出   
>  
>  文件模式和二进制模式，文本格式和二进制模式、缓冲和无缓冲I/O
>
>  使用既可以顺序访问，也可以随机访问的文件函数
---
## 与文件进行通信

Sometimes 需要从文件中读取信息，或者把信息写到文件。  

这种文件与程序交互的过程被称为 **重定向**  

### 文件是肾？

文件通常是磁盘或者固态硬盘上一段已经命名的存储区，比如 stdio.h。  

对操作系统而言，文件更复杂一些。  

大型文件会被分开存储，并且会多额外存储一些文件属性来方便I/O  

**C语言把文件看成是一段连续的字节**，每个字节都能被单独读取，这与UNIX环境中的文件结构类似。  

### 文本形式与二进制形式

本节描述：  

1. 文本格式与二进制格式
2. 文本模式与二进制模式
3. 文本内容与二进制内容

所有文件都以二进制形式进行存储（1/0）  

如果文件最初使用二进制编码的字符（例如 ASCII 或者 UNICODE）表示文本（就像C字符串），该文件就是文本文件，其中包含文本内容  

如果文件中的二进制值代表机器语言代码或者数值数据，或图片或者音乐或视频编码，该文件就是一个二进制文件，其中包含二进制内容  

UNIX用同一种方式处理文本内容以及二进制内容，C和UNIX都适用`\n`来表示换行。  

UNIX目录包含一个统计文件大小的计数，程序可以通过它来确认是否读取到文件末尾。  

其他系统有可能与UNIX处理文本的方式不同，比如早期 OS X macintosh 用 `\r` 表示换行,  
早期 MS-DOS 用 `\r\n` 表示换行。用嵌入的`Ctrl+Z`表示文件结尾。  

有些系统会对每一行填充空字符串来让每一行的长度相同。  

为了规范文本处理，C语言提供2种模式来操作文件，二进制模式和文本模式    

文本模式中，程序所见的文件内容和文件实际的内容是不一样的  
例如在一些旧系统中，以文本模式读取文件时，C会将`\r` 或
`\r\n`替换为`\n` 在写入文本内容时，又会把`\n`替换为`\r` 或 `\r\n`  

如果编辑 **早期 OS X macintosh 早期 MS-DOS 文本，应该用二进制模式，不会发生上述转义**

### I/O 级别

底层I/O **(low-level I/O)**: 使用操作系统提供的基本 I/O 模块  
标准高层级I/O **(standard high-level I/O)**: 使用C语言提供的 stdio.h  

由于无法保证所有操作系统都使用相同的底层I/O模型，**C标准只支持标准I/O包**。  
有些实现会提供底层库，**C标准建立了可移植的I/O模型**


### 标准文件
C程序会自动打开3个文件
1. 标准输入 **(standard input)** 通常是键盘
2. 标准输出 **(standard output)** 通常为显示器
3. 标准错误输出 **(standart error output)** 通常为显示器

第8章学过通过重定向将标准输出写入到文件，而不是显示器。  

<br>  

## 标准I/O

标准I/O的好处都有啥，谁说对了就给它：

1. 标准 I/O 有许多专门的函数统一处理 I/O 问题。
2. 使用输出缓冲以及输入缓冲，一次转移大块儿信息（通常至少512字节），而不是一个字节。

这种缓冲极大的提升了输入输出的效率，

上代码
```c
/* count.c -- 使用标准I/O */
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char * argv[]) {
    int ch;
    FILE * fp;
    unsigned long count = 0;
    if (argc != 2) {
        printf("> too many inputs\n");
        exit(EXIT_FAILURE);
    }
    if ((fp = fopen(argv[1], "r")) == NULL) {
        printf("Can't open %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }
    while ((ch = getc(fp)) != EOF) {
        putc(ch, stdout);
        count++;
    }
    fclose(fp);
    printf("File %s has %lu chars\n", argv[1], count);
    return 0;
}
```
hello 文件
```
This is a new file
Hello World!
C lang
with
o
```
编译代码
```shell
gcc -o prog -Wall main.c && ./prog
```
代码输出
```text
This is a new file
Hello World!
C lang
with
oFile hello has 45 chars
```

### 检查命令行参数

`argv[0]` 是程序的名称 也即是 `./prog` 有些系统可能识别不到 argv[0] 这样的处理兼容性可能不好  

`exit()` 会结束程序运行，并且向操作系统传递一些信息，通常返回 EXIT_SUCCESS 宏给操作系统代表程序运行成功  

main 中 `return 0` 可以改为 `exit(EXIT_SUCCESS)` 它俩是一个意思  

递归中，`return 0`只会提交给上一次递归, 而`exit(EXIT_SUCCESS)`会杀死程序  

<br>  

### fopen() 函数

`fopen(char * filename, char * mode)` 位于 stdio.h 头 接受一个文件名，一个模式  

| mode | 行为 |
| ---- | ---- |
|"r"   | 以读模式打开|
|"w"   | 以写模式打开，把现有文件长度截为0，如果文件不存在，会新建一个文件|
|"a"   | 以写模式打开，在现有文件末尾添加，如果文件不存在，会新建一个文件 |
|"r+"  | 以更新模式打开(即可以读写文件) |
|"w+"  | 以更新模式打开(即可以读写文件), 如果文件存在，则把现有文件长度截为0，不存在则新建 |
|"a+"  | 以更新模式打开(即可以读写文件), 如果文件存在，在现有文件末尾添加，不存在则新建 |
|"rb" "wb" "ab" "ab+" "a+b" ... | 与上方类似，增加'b'会将读写方式改成了二进制形式 |
|"wx" "wbx" "w+x" "wb+x" 或 "w+bx"| C11新增，类似非x模式，如果文件已存在，或以独占模式打开，则打开失败|

UNIX 或 LINUX 这样的系统，只有一种模式，带b不带b差别不大  

C11新增的x模式，相比以前有了更多特性  

如果以传统的写模式打开文件，会导致文件内容丢失 (截取长度为0)  
但是如果带有x标记，即使文件写不成功，文件内容也不会被删除  
如果系统环境允许，x会独占文件读写，程序的其他程序没办法同时访问这个文件的内容

1. 使用w打开现有文件会导致文件内容删除
2. 如果用带x字母的操作，将无法带开任何一种现有文件。

> fopen 返回一个 FILE 类型的指针
> FILE 类型是一个定义在 stdio.h 中的派生类型。
> FILE 指针不指向任何一个文件，它指向一个包含文件信息的数据对象
> 其中包括操作文件需要的IO信息  
> 标准I/O会根据这些信息决定在什么时候刷新或者晴空缓冲区

### getc() 函数和 putc() 函数

`getc()` `putc()` 和 `getchar()` `putchar()` 类似  

`getc(FILE * pt)` 从pt指向的文件读取一个字符  

`putc(char ch, FILE * pt)` 将字符写入pt指向的文件  

### 文件结尾

从文件读取数据的程序在遇到文件结尾时要停止  

`getc(FILE * pt)` 函数在读取数据时如果发现是文件结尾，它将返回一个特殊的值 `EOF`  
  
所以 C 读取过程只有在超过文件末尾时候才能发现文件结尾 (触发EOF返回)  

上代码  

case1
```c
int ch;
FILE * fp;

fp = fopen("file.txt", "r");
ch = getc(fp);

while (ch != EOF) {
    putchar(ch);
    ch = getc(fp); // 获取下一个字符
}
```
case2 优化 case1
```c
int ch;
FILE * fp;

fp = fopen("file.txt", "r");
while ((ch = getc(fp)) != EOF) {
    putchar(ch);
}
```

### fclose() 函数

```c
if (fclose(FILE * fp) != 0) { printf("Error Close file\n") }; 
```
`fclose` 可能因为磁盘满，硬盘移除等发生close错误。  



### 指向标准文件的指针

其实 `stdin` `stdout` `stderr` 在 `stdio.h` 头文件里有对应的 `FILE * pt`

<br>  

## 一个简单的文件压缩程序

#### 程序目标

1. 同时打开2个文件，一个以 "r" 打开 一个以 "w" 打开
2. 保留每3个字符中的1个字符的方式压缩第一个文件
3. 把压缩后的字符，写入文件2，以 .red 结尾。

```c
/* reducto.c -- 把文件压缩到原来的 3/1 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define DST_POSTFIX ".red"

int main(int argc, char * argv[]) {
    FILE * in, * out;
    int ch;
    int count = 0;
    char * name;
    // 验证参数个数
    if (argc < 2) {
        fprintf(stderr, "Usage: %s filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    // 设置输入
    if ( (in = fopen(argv[1], "r")) == NULL ) {
        fprintf(stderr, "Can not open file %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }
    // 设置文件名
    name = (char *) malloc((strlen(argv[1]) + 5) * sizeof(char));
    if (name == NULL) {
        fprintf(stderr, "Can not create output file\n");
        if (fclose(in) != 0) {
            fprintf(stderr, "Close %s file failed \n", argv[1]);
        }
        exit(2);
    }
    // 设置输出
    strcpy(name, argv[1]);
    name[strlen(name)] = '\0';
    strcat(name, DST_POSTFIX);

    if ((out = fopen(name, "w")) == NULL) {
        fprintf(stderr, "Can not create output file %s\n", name);
        if (fclose(in) != 0) {
            fprintf(stderr, "Close %s file failed \n", argv[1]);
        }
        free(name);
        exit(3);
    }
    while ((ch = getc(in)) != EOF) {
        if (count++ % 3 == 0) {
            putc(ch, out);
        }
    }
    if (fclose(in) != 0 || fclose(out) != 0) {
        fprintf(stderr, "%s %s close error\n", argv[1], name);
    }
    free(name);
    return 0;
}
```
控制台指令
```shell
gcc -o prog -Wall main.c && ./prog eddy
```
eddy 文件内容
```
So even Eddy come over ready.
```
eddy.red 文件内容
```
Send morey
```

<br>  

## 文件I/O 主要函数

`fprintf()`、`fscanf()`、`fgets()` 和 `fputs()`  
这些函数的输入都是 `FILE * fp`  

### fprintf() 和 fscanf()

工作方式与 `printf()` `scanf()` 类似

```c
/* add_a_word.c -- 使用fprintf()、fscanf() 和 rewind() */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 41

int main(void) {

    FILE * fp;
    char words[MAX];
    
    if ((fp = fopen("wordy", "a+")) == NULL ) // 尝试带开文件
    {
        fprintf(stderr, "ERROR: open wordy file error\n");
        exit(EXIT_FAILURE);
    }
    puts("Enter the words to the file; press the # to quit");
    
    while ((fscanf(stdin, "%40s", words)) == 1 && words[0] != '#') // 持续从 stdin 读取字符串
    {
        fprintf(fp, "%s\n", words);
    }
    rewind(fp); // 回到文件开始位置
    while ((fscanf(fp, "%s", words)) == 1) // 逐行读取
        puts(words);
    if (fclose(fp) != 0) {
        fprintf(stderr, "close file error\n");
    }
    return 0;
}
```
代码输出
```
Enter the words to the file; press the # to quit
1234567890qwertyuiopasdfghjklzxcvbnm1234567890qwertyuioasdfghjkzxcvbnm1234567890qwertyuioasdfghjk
3
#
1234567890qwertyuiopasdfghjklzxcvbnm1234
567890qwertyuioasdfghjkzxcvbnm1234567890
qwertyuioasdfghjk
3
```

`a+` 模式可以对文件进行持续读写  

`rewind` 可以让文件读指针回到开始初  

### fgets 和 fputs 函数

`fgets(char * pt, unsigned long STLEN, FILE * fp)`  

`pt` 指向 `char` 数组

`STLEN` 是字符串的大小

`fp` 是指向 FILE 的指针

fgets 读取范围：
1. 第1个 \n 后面
2. 文件结尾
3. STLEN - 1 个字符

然后 `fgets()` 会在末尾添加一个 `\0` 以将读取出的数据组合成一个字符串。  
字符串的大小是其字符数加上`\0`  
如果 `fgets()` 读完字符串上限之前就已经读完一整行，它会把表示换行的`\n` 放在 `\0` 前面
`fgets()` 遇到 `EOF` 会返回 `NULL`  


`fputs(char * pt, FILE * fp)`  
`fputs()` 接受2个参数，可以将字符串写入文件。fputs() 不会在末尾添加换行符。

<br>  

## 随机访问 fseek() 和 ftell() 

`fseek()` 有3个参数，返回一个 `int` 类型  
`ftell()` 有一个参数，返回一个 `long` 类型

```c
/* reverse.c -- 倒序显示文件内容 */
#include <stdio.h>
#include <stdlib.h>

#define CTRL_Z '\032' // Dos 文本文件中的结尾标记
#define S_LEN 81

int main(void) {

    char file[S_LEN];
    char ch;
    FILE * fp;
    long count, last;
    puts("Enter the name of the file to be processed");
    scanf("%80s", file);

    if ((fp = fopen(file, "rb")) == NULL) // 只读模式，不涉及文件修改
    {
        printf("reverse cant not read file %s\n", file);
        exit(EXIT_FAILURE);
    }

    fseek(fp, 0L, SEEK_END); // 定位当前位置到文件末尾
    last = ftell(fp);        // 计算文件从开始到当前位置的字节数量

    for (count = 1L; count <= last; count++) {
        fseek(fp, -count, SEEK_END);
        ch = getc(fp);
        /* 
            MS-DOS 部分文件结尾是 CTRL+Z
            MS-DOS 部分文件的换行符 是 \r\n
        */
        if (ch != CTRL_Z && ch != '\r' && ch != '\0')    
        {
            putchar(ch);
        }
    }
    putchar('\n');
    fclose(fp);
    return 0;
}
```
代码输出
```
Enter the name of the file to be processed
hello
o
htiw
gnal C
!dlroW olleH
elif wen a si sihT
```

该程序使用二进制模式，以方处理 MS-DOS 以及 UNIX 文件，但是在其他环境中的文本格式文件中可能无法使用  

### fseek() 和 ftell() 工作原理

`fseek(FILE * fp, long offset, MODE)`
1. `fp` 是一个指向文件的指针
2. `offset` 是偏移量，`long` 类型 `offset > 0L` 代表向前移动，`offset < 0L` 代表向后移动，`offset = 0L` 代表原地不动。
3. `MODE` 是 `stdio.h` 头文件中的宏, 意义如下

|宏|偏移量的起始点|
|--------|------|
|SEEK_SET|文件开始处|
|SEEK_CUR|文件当前位置|
|SEEK_END|文件末尾|

上例
```c
#include <stdio.h>

FILE * fp;

fseek(fp, 0L, SEEK_SET)   // 定位到文件开始位置
fseek(fp, 10L, SEEK_SET)  // 定位到文件的第10个字节
fseek(fp, 2L, SEEK_CUR)   // 定位到当前文件位置的后2个字节
fseek(fp, 0L, SEEK_END)   // 定位到文件末尾
fseek(fp, -10L, SEEK_END) // 定位到文件末尾前10个字节
```

对于这些调用其实还有一些限制  

如果正常，`fseek()` 返回 `0` 如果发生错误（移动范围越界，超过文本）返回 `-1`

`ftell()` 返回一个`long`类型从文件开始位置到当前位置的字节数量

最初的UNIX中，通过 `ftell() == 0` 来判断文件是否在起始位置

**适用于以二进制打开模式**

### 二进制和文本模式

上述程序在 MS-DOS 和 UNIX 都能打开，UNIX 只有一种文本格式，相对通用。  
然而许多 MS-DOS 文件编辑器都以 `Ctrl+Z` 对文本进行结尾，要特别注意。
以文本格式打开文件的时候，C 能识别到文件的这个结尾  
但是以二进制打开文件时，`Ctrl+Z `被看作是一个字符 `\032` 而实际的文件结尾在这个字符后面  
文件结尾符可能在`Ctrl+Z`后面，或者文件中用空字符`\0`填充，使文件大小是256的整数倍
DOS环境不会打印`\0`

二进制和文本模式的另一个不同点在于，MS-DOS 用 \r\n 来组合表示文本文件换行  
以文本模式打开文件时，C 会将 `\r\n` 转为 `\n`, 但是以二进制打开时，会将换行看成2个字符  

`ftell()` 函数在文本和二进制模式中的工作方式不同，许多系统的文本文件模型也和UNIX有很大出入  
导致从文件开始处统计字节数量变得没什么意义  
ANSI C 规定 对于文本模式 `ftell()` 可以作为 `fseek()` 的第二个参数
对于 `MS-DOS` `ftell()` 把 `\r\n` 当作一个字节来计数